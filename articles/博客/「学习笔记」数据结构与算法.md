 ## 1.数据结构绪论

### 1.1.基本概念知识

- 数据结构：研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科

- **`程序设计=数据结构+算法`**

- 数据：计算机中可以操纵的对象；描述客观事物的符号

  - 整性、实型等数值类型

  - 声音、图像、视频等非数值类型

  - 前提

    - 可以输入到计算机中
    - 能被程序处理
  
-   数据元素：组成数据的有一定意义的基本单位，在计算机中通常作为整体来处理

  - 人类：人-数据元素
  - 畜类：牛、羊、马等
  
- 数据项：一个元素可以由若干个数据项组成

  - 人（数据元素）

    - 眼、耳-数据项
    - 年龄、性别

  - 数据项是数据不可分割的最小单位
  
- 数据对象：性质相同的元素的集合，是数据的子集
  - 张三（数据元素）、李四；（该集合成为数据对象）
  
    

### 1.2.逻辑结构与物理结构

#### 1.2.1.逻辑结构

- 逻辑结构：数据对象中数据元素之间的相互关系
   - 集合结构：同属一个集合，之间无关系

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-df4d648a554b4dfbd9e690fbb537d1b5-1-739f3f.png" alt="1" style="zoom: 33%;" />

      

   - 线性结构：一对一关系

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-e0716d66c407c6a1346d892d3579bb83-2-14e75e.png" alt="1" style="zoom: 40%;" />

   - 树形结构：一对多的层次关系

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-ac44e2386563a26f4eaf5bc316e5ebe3-3-54651c.png" alt="1" style="zoom: 40%;" />

   - 图形结构：多对多的关系
   
      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-b791968153b6c4cab78fa4b104e4ece1-4-bccdfb.png" alt="1" style="zoom: 40%;" />

#### 1.2.2.物理结构

- 物理结构（存储结构）：数据的逻辑结构在计算机中的存储形式

   - 顺序存储结构
      - 把数据元素存放在地址连续的存储单元里
      - 数据间的逻辑关系和物理关系是一致的

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-9d13d668a08feac7e94cd3d7523b8f1c-5-f894be.png" alt="1" style="zoom: 33%;" />

   - 链式存储结构
      - 把数据元素存放在任意的存储单元里，可连续，也可不连续
      - 数据元素的存储关系不能反映其逻辑关系
      - 需用指针存放数据元素的地址

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-37f284a0255262e4c01f77e542e38fd2-6-4425d7.png" alt="1" style="zoom: 33%;" />



### 1.3.抽象数据类型

#### 1.3.1.数据类型

- 数据类型：一组性质相同的值的集合及定义在此集合的一些操作的总称

  - 原子类型：不可分解，如整形

  - 结构类型：由若干类型组成，可再分解，如整型数组

    > 抽象是指抽取出事务具有的普遍性的本质

#### 1.3.2.抽象数据类型

- 抽象数据类型（ADT）：指一个数学模型及定义在该模型上的一组操作

  - ```pseudocode
    ADT 抽象数据类型
    Data
      数据元素之间逻辑关系的定义
    Operation
      操作1
        初始条件
        操作结果描述
      操作2
        ...
      操作n
        ...
    endADT
    ```


------



## 2.算法

### 2.1.基本概念知识

- 算法的特性

  - 输入：算法具有零个或多个输入
  - 输出：算法具有至少一个或多个输出
  - 有穷性：算法在执行有限的步骤之后，自动结束而不会出现循环，并且每一个步骤在可接受的时间内完成
  - 确定性：算法的每一步都具有确定的含义，不会出现二义性
  - 可行性：算法的每一步都必须是可行的，即每一步都能够通过执行有限次数完成

- 算大的设计要求

  - 正确性
  - 可读性
  - 健壮性：当输入数据不合法时，算法也能做出相关处理
  - 时间效率高和存储量低

- 事前分析估算方法

  - 决定因素
    - 算法的好坏
    - 问题的输入规模


  - ```c
    for(i=1;i<=n;i++)//执行n+1次
    	sum=sum+i;//执行n次
    sum=(1+n)*n/2;//执行1次
    ```

- 函数的渐近增长

  - 阶数（主）
  - 系数



### 2.2.算法的时间复杂度

#### 2.2.1.定义

- 算法的时间复杂度

  - 记作`T(n)=O(f(n))`

    > `T(n)`：语句总的执行次数
    >
    > `f(n)`：问题规模n的某个函数


- `T(n)`增长最慢的算法称为最优算法
- 推导大O阶方法

  - 用1取代常数
  - 只留最高阶项
  - 最高阶项系数取1

#### 2.2.2.常见时间复杂度

> **分析算法的复杂度，关键就是要分析循环结构的运行情况**


- 常数阶

  - **O(1)**
    
    - ```c
      int sum,n=100;
      sum=(1+n)*n/2;//f(n)=2
      ```
  
- 线性阶

  - **O(n)**

    - ```c
      for(int i=0;i<n;i++)
        	//执行n次
      ```

- 对数阶

  - **O(logn)**

    - ```c
      int count=1;
      while(count<n)
      	count=count*2;//执行log2n次;
      ```

    - > 2<sup>x</sup>=n，则x=log<sub>2</sub>n  

- 平方阶

  - **O(n<sup>2</sup>)**

    - ```c
        for(int i=0;i<n;i++)
        	for(int j=0;j<n;j++)
        		//执行n*n次
        ```

  - **O(mn)**

    - ```c
      int i,j;
      for(i=0;i<m;i++)
      	for(j=0;j<n;j++)
      		//执行m*n次
      ```


- 常见的时间复杂度
  - **O(1)<O(logn)<O(n)<O(nlogn)<O(n<sup>2</sup>)<O(n<sup>3</sup>)<O(2<sup>n</sup>)<O(n!)<O(n<sup>n</sup>)**
- 最坏情况与平均情况
  - 无特殊说明，均指最坏时间复杂度



### 2.3.算法的空间复杂度

- 计算公式：`S(n)=O(f(n))`

  > n为问题规模
  >
  > f(n)为语句关于n所占存储空间的函数
  

------



## 3.线性表

### 3.1.线性表的定义

- 线性表（List）：零个或多个数据元素的有限序列
  - 第一个元素无前驱，最后一个元素无后继
  - 其他每个元素都有且只有一个前驱和后继
  - 线性表元素的个数n（n$\geq$0）定义为线性表的长度，当n=0时，称为空表
  - 在较复杂的线性表中，一个数据元素可以由若干个数据项组成



### 3.2.线性表的顺序存储结构

#### 3.2.1.顺序存储结构的定义

- 线性表的顺序存储结构：指的是用一段连续的存储单元一次存储线性表的数据元素

- 顺序存储结构代码描述

  - 可以用C语言的一维数组来实现顺序存储结构

  - ```c
    #define MAXSIZE 100 //存储空间初始分配量
    //线性表的顺序存储结构
    typedef struct
    {
        ElemType data[MAXSIZE]; //数组存储数据元素，最大值为MAXSIZE
        int length;             //线性表当前长度
    } SqList;
    ```

  - 顺序存储结构需要三个属性

    - 存储空间的初始位置：数组data，它的存储位置就是存储空间的存储位置
    - 线性表的最大存储容量：数组长度MAXSIZE
    - 线性表的当前长度：length

- 数据长度与线性表长度的区别

  - 数据长度，即数组的长度是存放线性表的存储空间的长度
  - 线性表的长度是线性表中数据元素的个数
  - 在任意时刻，线性表的长度应该小于等于数组的长度

- 地址计算方法

  - $LOC(a_{i+1})=LOC(a_i)+c$

  - $LOC(a_i)=LOC(a_1)+(i-1)*c$

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-a4791b52a0f4e14e4b05a3fb3b7dafa8-7-a7595b.png" alt="1" style="zoom: 50%;" />

#### 3.2.2.顺序存储结构的读取

- 获得元素操作

  - `GetElem(L,i,&e)`：用e返回L中第i个数据元素的值

  - ```c
    //初始条件：顺序线性表L已存在，1<=i<=ListLength(L)
    //操作结果：用e返回L中第i个数据元素的值
    Status GetElem(SqList L, int i, ElemType *e)
    {
        if (L.length == 0 || i < 1 || i > L.length)
        {
            return ERROR; //线性表不存在或不合法
        }
        *e = L.data[i - 1]; //找到第i个元素，其下标为i-1
        return OK;
    }
    ```



#### 3.2.3.顺序存储结构的插入与删除

- 插入操作

  - `ListInsert(&L,i,e)`：在L中第i个元素之前插入新元素e，表长加1

  - 插入算法思路

    - 如果插入位置不合理，抛出异常
    - 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量
    - 从最后一个元素开始向前遍历到第i个位置，分别将它们向后移动一个位置
    - 将要插入的元素填入位置i处
    - 表长加1

  - ```c
    //初始条件：顺序线性表L已存在，1<=i<=ListLength(L)
    //操作结果：在L中第i个元素之前插入新元素e，表长加1
    Status ListInsert(SqList *L, int i, ElemType e)
    {
        int k;
        if (L->length == MAXSIZE)
        { //顺序线性表已满
            return ERROR;
        }
        if (i < 1 || i > L->length + 1)
        { //i不在范围内
            return ERROR;
        }
        if (i < L->length)
        { //插入元素不在表尾
            for (k = L->length - 1; k >= i - 1; k--)
            {
                L->data[k + 1] = L->data[k]; //将要插入位置后的数据元素向后移动一位
            }
        }
        L->data[i - 1] = e; //将新元素插入
        L->length++;        //表长加1
        return OK;
    }
    ```

  - 时间复杂度

    - 最好情况：插入到最后一个位置，无需移动；**O(1)**
    - 最坏情况：移动所有的元素；**O(n)**
    - 平均情况：平均移动次数和最中间的元素的移动次数相等，(n-1)/2；**O(n)**

- 删除操作

  - `ListDelete(&L,i,&e)`：删除L的第i个数据元素，并用e返回其值，L的长度减1
  
  - 删除算法思路
    - 如果删除位置不合理，抛出异常
    
    - 取出删除元素
    
    - 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
    
    - 表长减1
    
  - ```c
    //初始条件：顺序线性表L已存在，1<=i<=ListLength(L)
    //操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1
    Status ListDelete(SqList *L, int i, ElemType *e)
    {
        int k;
        if (L->length == 0)
        { //线性表为空
            return ERROR;
        }
        if (i < 1 || i > L->length)
        { //删除位置不正确
            return ERROR;
        }
        *e = L->data[i - 1]; //将要删除的值给e
        if (i < L->length)
        { //删除不是最后位置
            for (k = i; k < L->length; k++)
            {
                L->data[k - 1] = L->data[k]; //将删除位置后继元素前移
            }
        }
        L->length--; //表长减1
        return OK;
    }
    ```
  
  - 时间复杂度
  
    - 最好情况：删除最后一个位置，无需移动；**O(1)**
    - 最坏情况：移动所有的元素；**O(n)**
    - 平均情况：平均移动次数和最中间的元素的移动次数相等，(n-1)/2；**O(n)**

#### 3.2.3.顺序存储结构的优缺点

- 优点
  - 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
  - 可以快速地存取表中任一位置的元素
- 缺点
  - 插入和删除操作需要移动大量元素
  - 当线性表长度变化较大时，难以确定存储空间的容量
  - 造成存储空间的“碎片”



### 3.3.线性表的链式存储结构

#### 3.3.1.链式存储结构的定义

- 线性表的链式存储结构

  - 对数据元素来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的存储位置

  - 存储数据元素的域成为数据域

  - 存储直接后继位置的域称为指针域

  - 数据域和指针域两部分信息组成数据元素的存储映像，称为结点（Node）

  - n个结点链结成一个链表，即为线性表的链式存储结构

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-c6aec048950a690fa55192cd293e355b-8-f9b040.png" alt="1" style="zoom: 40%;" />

    > 链表的每个结点中只包含一个指针域，称其为单链表

- 头指针与头结点

  - 头指针：链表中第一个结点的存储位置

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-a3ab2d4cc1c889cf847300e8d4c2f3c6-9-9565ec.png" alt="1" style="zoom: 50%;" />

  - 头结点：在链表的第一个结点前附设一个结点，称为头结点

    - 头结点的数据域可以不存任何信息，也可以存储如线性表长度等附加信息
    - 头结点的指针域存储指向第一个结点的指针

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-bd9489442364f6496218ed0502c6eb34-10-e6103a.png" alt="1" style="zoom: 50%;" />

  - 头指针与头结点的异同

    - 头指针
      - 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针
      - 头指针具有标识作用，所以常用头指针冠以链表的名字
      - 无论链表是否为空，头指针均不为空；头指针是链表的必要元素
    - 头结点
      - 头结点是为了操作的统一和方便而设立的，放在第一元素结点之前，其数据域一般无意义
      - 有了头结点，对在第一元素结点前插入节点和删除第一结点，其操作与其他的操作就统一了
      - 头结点不一定是链表的必要元素

- 链式存储结构代码描述

  - ```c
    //线性表的单链表存储结构
    typedef struct Node
    {
        ElemType data;
        struct Node *next;
    } Node;
    typedef struct Node *LinkList; //定义LinkList
    ```

#### 3.3.2.单链表的读取

- 单链表的读取

  - `GetElem(L,i,&e)`：用e返回L中第i个数据元素的值

  - 获得链表第i个数据的算法思路
    - 声明一指针`p`指向链表头结点，初始化j从1开始
    - 当j<i时，就遍历链表，让`p`的指针向后移动，不断指向下一结点，j累加1
    - 若到链表末尾`p`为空，则说明第i个结点不存在
    - 否则查找成功，则返回节点`p`的数据

  - ```c
    //初始条件：顺序线性表L已存在，1<=i<=ListLength(L)
    //操作结果：用e返回L中第i个数据元素的值
    Status GetElem(LinkList L, int i, ElemType *e)
    {
        int j;
        LinkList p;  //声明一指针p
        p = L->next; //让p指向链表L的第一个结点
        j = 1;       //j为计数器
        while (p && j < i)
        {                //p不为空且计数器j还没有等于i时，循环继续
            p = p->next; //让p指向下一个结点
            ++j;
        }
        if (!p || j > i)
        { //第i个结点不存在
            return ERROR;
        }
        *e = p->data; //取第i个结点的数据
        return OK;
    }
    ```

  - 最坏情况的时间复杂度：**O(n)**

#### 3.3.3.单链表的插入与删除

- 单链表的插入

  - `ListInsert(&L,i,e)`：在L中第i个结点位置之前插入新的数据元素e，L的长度加1

  - 单链表第i个数据插入结点的算法思路

    - 声明一指针`p`指向链表头结点，初始化j从1开始
    - 当j<i时，就遍历链表，让`p`的指针向后移动，不断指向下一结点，j累加1
    - 若到链表末尾`p`为空，则说明第i个结点不存在
    - 否则查找成功，在系统中生成空结点`s`
    - 将数据元素e赋值给`s->data`
    - 单链表的插入标准语句`s->next=p->next;p->next=s;`

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-b1ebe111b307c0a34c08f5752040c86b-11-2d0d60.png" alt="1" style="zoom: 60%;" />

  - ```c
    //初始条件：顺序线性表L已存在，1<=i<=ListLength(L)
    //操作结果：在L中第i个结点位置之前插入新的数据元素e，L的长度加1
    Status ListInsert(LinkList *L, int i, ElemType e)
    {
        int j;
        LinkList p, s;
        p = *L; //p指向头结点
        j = 1;
        while (p && j < i)
        { //寻找第i-1个结点
            p = p->next;
            ++j;
        }
        if (!p || j > i)
        { //第i个结点不存在
            return ERROR;
        }
        s = (LinkList)malloc(sizeof(Node)); //生成新结点
        s->data = e;                        //将数据元素e赋值给s->data
        s->next = p->next;                  //将p的后继结点赋值给s的后继
        p->next = s;                        //将s赋值给p的后继
        return OK;
    }
    ```

  - 时间复杂度：**O(n)**

- 单链表的删除

  - `ListDelete(&L,i,&e)`：删除L的第i个结点，并用e返回其值，L的长度减1

  - 单链表第i个数据删除结点的算法思路

    - 声明一指针`p`指向链表头结点，初始化j从1开始
    - 当j<i时，就遍历链表，让`p`的指针向后移动，不断指向下一结点，j累加1
    - 若到链表末尾`p`为空，则说明第i个结点不存在
    - 否则查找成功，将欲删除的结点`p->next`赋值给`q`
    - 单链表的删除标准语句`p->next=q->next`
    - 将`q`结点中的数据赋值给e，作为返回
    - 释放结点`q`

    

  - ```c
    //初始条件：顺序线性表L已存在，1<=i<=ListLength(L)
    //操作结果：删除L的第i个结点，并用e返回其值，L的长度减1
    Status ListDelete(LinkList *L, int i, ElemType *e)
    {
        int j;
        LinkList p, q;
        p = *L; //p指向头结点
        j = 1;
        while (p->next && j < i)
        { //寻找第i-1个结点
            p = p->next;
            ++j;
        }
        if (!(p->next) || j > i)
        { //第i个结点不存在
            return ERROR;
        }
        q = p->next;       //将第i个结点赋值给q，即待删除结点p->next
        p->next = q->next; //将q的后继赋值给p的后继
        *e = q->data;      //将q结点中的数据给e
        free(q);           //让系统回收此结点，释放内存
        return OK;
    }
    ```

  - 时间复杂度：**O(n)**

- 单链表插入删除的优点

  - 从整个算法来说，时间复杂度都是**O(n)**
  - 在不知道第i个元素的指针位置，单链表在插入和删除操作上，与线性表的顺序存储结构时间复杂度相同
  - 从第i个位置，插入10个元素；对于顺序存储结构，每一次插入都需要移动n-i个元素，时间复杂度每次都是**O(n)**；对于单链表，只需在第一次时找到第i个位置的指针，此时时间复杂度为**O(n)**，接下来只是简
    单地通过赋值移动指针而已，时间复杂度都是**O(1)**
  - 显然，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显

#### 3.3.4.单链表的整表创建与整表删除

- 单链表的整表创建（头插法）

  - `CreateListHead(&L,n)`：随机产生n个元素的值，建立带表头结点的单链表L（头插法）

  - 单链表整表创建（头插法）的算法思路
    - 声明一指针`p`和计数器i
    - 初始化一空链表L
    - 让L的头结点的指针指向`NULL`，即建立一个带头结点的单链表
    - 循环
      - 生成一新结点赋值给`p`
      - 随机生成一数字赋值给`p`的数据域`p->data`
      - 将p插入到头结点与前一新结点之前

    

  - ```c
    //随机产生n个元素的值，建立带表头结点的单链表L（头插法）
    void CreateListHead(LinkList *L, int n)
    {
        LinkList p;
        int i;
        srand(time(0));                      //初始化随机数种子
        *L = (LinkList)malloc(sizeof(Node)); //先建立一个带头结点的单链表
        (*L)->next = NULL;                   //头结点指向NULL
        for (i = 0; i < n; i++)
        {
            p = (LinkList)malloc(sizeof(Node)); //生成新结点
            p->data = rand() % 100 + 1;         //随机生成100以内的数字
            p->next = (*L)->next;
            (*L)->next = p; //插入到表头
        }
    }
    ```

- 单链表的整表创建（尾插法）

  - `CreateListTail(&L,n)`：随机产生n个元素的值，建立带表头结点的单链表L（尾插法）

  - ```c
    //随机产生n个元素的值，建立带表头结点的单链表L（尾插法）
    void CreateListTail(LinkList *L, int n)
    {
        LinkList p, r;
        int i;
        srand(time(0));                      //初始化随机数种子
        *L = (LinkList)malloc(sizeof(Node)); //先建立一个带头结点的单链表
        r = *L;                              //r为指向尾部的结点
        for (i = 0; i < n; i++)
        {
            p = (LinkList)malloc(sizeof(Node)); //生成新结点
            p->data = rand() % 100 + 1;         //随机生成100以内的数字
            r->next = p;                        //将表尾终端结点的指针指向新结点
            r = p;                              //将当前的新结点定义为表尾终端结点
        }
        r->next = NULL; //表示当前链表结束
    }
    ```

- 单链表的整表删除

  - `ClearList(&L)`：将L重置为空表

  - 单链表整表删除的思路

    - 声明一指针`p`和`q`
    - 将第一个结点赋值给`p`
    - 循环
      - 将下一结点赋值给`q`
      - 释放`p`
      - 将`q`赋值给`p`

    
  
  - ```c
    //将L重置为空表
    Status ClearList(LinkList *L)
    {
        LinkList p, q;
        p = (*L)->next; //p指向第一个结点
        while (p)
        {
            q = p->next; //将p的下一个结点赋给q
            free(p);     //释放当前结点p
            p = q;       //将下一节点q赋值给p
        }
        (*L)->next = NULL; //头结点指针域为空
        return OK;
    }
    ```

#### 3.3.5.单链表结构与顺序存储结构的对比

- 存储分配方式
  - 顺序存储结构用一段连续的存储单元以此存储线性表的数据元素
  - 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素
- 时间性能
  - 查找
    - 顺序存储结构：**O(1)**
    - 单链表：**O(n)**
  - 插入和删除
    - 顺序存储结构需要平均移动表长一半的元素，平均情况的时间复杂度为**O(n)**
    - 单链表在找到某位置的指针后，插入和删除的时间复杂度仅为**O(1)**
- 空间性能
  - 顺序存储结构需要预分配存储空间，分大了浪费，分小了易发生溢出
  - 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制



### 3.4.静态链表

#### 3.4.1.静态链表的定义

- 静态链表存储结构的代码描述

  - ```c
    typedef struct
    {
        ElemType data;
        int cur; //游标（Cursor），为0时表示无指向
    } Component, StaticLinkList[MAXSIZE];
    ```

  - 数据域

    - data：存放数据元素
    - cur：存放该元素的后继在数组中的下标，叫做游标

  - 备用链表：未被使用的元素
  - 特殊元素
    - 第一个元素：存放备用链表的第一个结点的下标
    - 最后一个元素：存放第一个有数值的元素的下标

- 初始化静态链表

  - `InitList(space)`

  - ```c
    //将一维数组space中各分量链成一备用链表
    //space[0].cur为头指针，"0"表示为空指针
    Status InitList(StaticLinkList space)
    {
        int i;
        for (i = 0; i < MAXSIZE - 1; i++)
        {
            space[i].cur = i + 1;
        }
        space[MAXSIZE - 1].cur = 0; //目前静态链表为空，最后一个元素的cur为0
        return OK;
    }
    ```

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-5a3ef36bba920c5c21f2a6ec489cb7c5-12-8b84d1.png" alt="1" style="zoom: 60%;" />

#### 3.4.2.静态链表的插入与删除

- 辨明数组中未被使用的分量：将所有未被使用过的及已被删除的分量用游标链成一个备用的链表

- 申请空间

  - `Malloc_SLL(space)`：若备用空间链表非空，则返回分配的结点下标，否则返回0

  - ```c
    //若备用空间链表非空，则返回分配的结点下标，否则返回0
    int Malloc_SLL(StaticLinkList space)
    {
        int i = space[0].cur; //当前数组第一个元素的cur存的值，
                              //就是要返回的第一个备用空间的下标
    
        if (space[0].cur)
        {
            space[0].cur = space[i].cur; //由于要拿出一个分量来使用了
                                         //所以我们就得把它的下一个分量来做备用
        }
        return i;
    }
    ```

- 插入操作

  - `ListInsert(L,i,e)`：在L中第i个元素之前插入新的元素e

    

  - ```c
    //在L中第i个元素之前插入新的元素e
    Status ListInsert(StaticLinkList L, int i, ElemType e)
    {
        int j, k, l;
        k = MAXSIZE - 1; //注意k首先是最后一个元素的下标
        if (i < 1 || i > ListLength(L) + 1)
        {
            return ERROR;
        }
        j = Malloc_SLL(L); //获得空闲分量下标
        if (j)
        {
            L[j].data = e; //将数据赋值给此分量的data
            for (l = 1; l <= i - 1; l++)
            {
                k = L[k].cur; //找到第i个元素之前的位置
            }
            L[j].cur = L[k].cur; //把第i个元素之前的cur赋值给新元素的cur
            L[k].cur = j;        //把新元素的下标赋值给第i个元素之前元素的cur
            return OK;
        }
        return ERROR;
    }
    ```

- 释放空间

  - `Free_SLL(space,k)`：将下标为k的空闲结点回收到备用链表

  - ```c
    //将下标为k的空闲结点回收到备用链表
    void Free_SLL(StaticLinkList space, int k)
    {
        space[k].cur = space[0].cur; //把第一个元素cur值赋给要删除的分量cur
        space[0].cur = k;            //把要删除的分量下标赋值给第一个元素的cur
    }
    ```

- 删除操作

  - `ListDelete(L,i,&e)`：删除L中第i个数据元素

  - ```c
    //删除L中第i个数据元素
    Status ListDelete(StaticLinkList L, int i, int *e)
    {
        int j, k;
        if (i < 1 || i > ListLength(L))
        {
            return ERROR;
        }
        k = MAXSIZE - 1;
        for (j = 1; j <= i - 1; j++)
        {
            k = L[k].cur;
        }
        j = L[k].cur;
        L[k].cur=L[j].cur;
        *e = L[j].data;
        Free_SLL(L, j);
        return OK;
    }
    ```

- 静态链表长度

  - `ListLength(L)`：返回L中数据元素个数

  - ```c
    //返回L中数据元素个数
    int ListLength(StaticLinkList L)
    {
        int j = 0;
        int i = L[MAXSIZE - 1].cur;
        while (i)
        {
            i = L[i].cur;
            j++;
        }
        return j;
    }
    ```

#### 3.4.3.静态链表的优缺点

- 优点
  - 再插入和删除操作时，只需要修改游标，不需要移动元素
- 缺点
  - 没有解决连续存储分配带来的表长难以确定的问题
  - 失去了顺序存储随机存取的特性

### 3.5.循环链表与双向链表

- 循环链表
  - 将单链表中终端结点的指针端由空指针改为指向头结点，就是整个链表形成一个环，这种头尾相接的链表称为单循环链表，简称**循环链表**

- 双向链表

  - 双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域

  - 双向链表存储结构

    - ```c
      //线性表的双向链表存储结构
      typedef struct DulNode
      {
          ElemType data;
          struct DulNode *prior; //直接前驱指针
          struct DulNode *next;  //直接后继指针
      } DulNode, *DuLinkList;
      ```

  - 插入操作

    - ```c
      s->prior = p;       //把p赋值给s的前驱
      s->next = p->next;  //把p->next赋值给s的后继
      p->next->prior = s; //把s赋值给p->next的前驱
      p->next = s;        //把s赋值给p的后继
      ```

    - <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-653562c5cbd356e66ba7809e9895fc90-13-6da580.png" alt="1" style="zoom: 40%;" />

  - 删除操作

    - ```c
      p->prior->next = p->next;  //把p->next赋值给p->prior的后继
      p->next->prior = p->prior; //把p->prior赋值给p->next的前驱
      free(p);                   //释放结点
      ```

-----



## 4.栈与队列

### 4.1.栈的定义

- 栈（Stack）：是限定仅在表尾进行插入和删除操作的线性表
  - 栈顶（top）：允许插入的一段
  - 栈底（bottom）：不允许插入的一段
  - 不放任何数据元素的栈称为空栈
  - 栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构
  - 站的插入操作，叫做进栈，也称压栈、入栈
  - 栈的删除操作，叫做出栈，也称弹栈



### 4.2.栈的顺序存储结构

#### 4.2.1.顺序存储结构的定义

- 栈的顺序存储结构

  - 下标为0的一段作为栈底
  - 定义一个`top`变量来表示栈顶元素
  - 通常把空栈的判定条件定为`top`等于-1

- 顺序存储结构代码描述

  - ```c
    typedef struct
    {
        ElemType data[MAXSIZE];
        int top; //用于栈顶指针
    } SqStack;
    ```

#### 4.2.2.顺序栈的进栈与出栈

- 进栈操作

  - `Push(&S,e)`：插入元素e为新的栈顶元素

  - ```c
    //插入元素e为新的栈顶元素
    Status Push(SqStack *S, ElemType e)
    {
        if (S->top == MAXSIZE - 1)
        { //栈满
            return ERROR;
        }
        S->top++;            //栈顶指针加1
        S->data[S->top] = e; //将新插入元素赋值给栈顶空间
        return OK;
    }
    ```

  - 时间复杂度：**O(1)**

    

- 出栈操作

  - `Pop(&S,&e)`：若栈不空，则删除S的栈顶元素，用e返回其值

  - ```c
    //若栈不空，则删除S的栈顶元素，用e返回其值
    Status Pop(SqStack *S, ElemType *e)
    {
        if (S->top == -1)
        { //空栈
            return ERROR;
        }
        *e = S->data[S->top]; //用e返回删除值
        S->top--;             //栈顶指针-1
        return OK;
    }
    ```

  - 时间复杂度：**O(1)**

#### 4.2.3.两栈共享空间

- 两站共享空间结构

  - 栈满：`top1+1==top2`
  - 栈空：`top1=-1`（栈1空）；`top2=n`（栈2空）
  - 判断：`stackNumber`；=1时对栈1进行操作，=2时对栈2进行操作
  - 此结构通常用于两个栈的空间需求有相反关系

- 两站共享空间结构代码描述

  - ```c
    typedef struct
    {
        ElemType data[MAXSIZE];
        int top1; //栈1栈顶指针
        int top2; //栈2栈顶指针
    } SqDoubleStack;
    ```

- 进栈操作

  - `Push(&S,e,stackNumber)`：插入元素e为新的栈顶元素

  - ```c
    
    //插入元素e为新的栈顶元素
    Status Push(SqDoubleStack *S, ElemType e, int stackNumber)
    {
        if (S->top1 + 1 == S->top2)
        { //栈满
            return ERROR;
        }
        if (stackNumber == 1)
        {                           //栈1有元素进栈
            S->data[++S->top1] = e; //若栈1则先top1+1后给数组元素赋值
        }
        if (stackNumber == 2)
        {                           //栈1有元素进栈
            S->data[--S->top2] = e; //若栈2则先top2-1后给数组元素赋值
        }
        return OK;
    }
    ```

- 出栈操作

  - `Pop(&S,&e,stackNumber)`：若栈不空，则删除S的栈顶元素，用e返回其值

  - ```c
    //若栈不空，则删除S的栈顶元素，用e返回其值
    Status Pop(SqDoubleStack *S, ElemType *e, int stackNumber)
    {
        if (stackNumber == 1)
        {
            if (S->top1 == -1)
            { //栈1已空
                return ERROR;
            }
            *e = S->data[S->top1];
            S->top1--; //将栈1的栈顶元素出战
        }
        else if (stackNumber == 2)
        {
            if (S->top2 == MAXSIZE)
            { //栈2已空
                return ERROR;
            }
            *e = S->data[S->top2];
            S->top2++; //将栈1的栈顶元素出战
        }
    }
    ```



### 4.3.栈的链式存储结构及实现

#### 4.3.1.链式存储结构的定义

-  栈的链式存储结构：链栈

  - 栈顶放在链表的头部
  - 一般没有头结点
  - 栈空：`top=NULL` 

- 链式存储结构代码描述    

  - ```c
    typedef struct StackNode
    {
        ElemType data;
        struct StackNode *next;
    } StackNode, *LinkStackPtr;
    typedef struct LinkStack
    {
        LinkStackPtr top;
        int count;
    } LinkStack;
    ```

#### 4.3.2.链栈栈的进栈与出栈

- 进栈操作

  - `Push(&S,e)`：插入元素e为新的栈顶元素

  - ```c
    //插入元素e为新的栈顶元素
    Status Push(LinkStack *S, ElemType e)
    {
        LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));
        s->data = e;
        s->next = S->top; //把当前的栈顶元素赋值给新结点的直接后继
        S->top = s;       //将新结点s赋值给栈顶元素
        S->count++;
        return OK;
    }
    ```

  - 时间复杂度：**O(1)**

- 出栈操作

  - `Pop(&S,&e)`：若栈不空，则删除S的栈顶元素，用e返回其值

  - ```c
    //若栈不空，则删除S的栈顶元素，用e返回其值
    Status Pop(LinkStack *S, ElemType *e)
    {
        LinkStackPtr p;
        if (StackEmpty(*S))
        {
            return ERROR;
        }
        *e = S->top->data;
        p = S->top;            //将栈顶结点赋值给p
        S->top = S->top->next; //使得栈顶指针下移一位，指向后一结点
        free(p);               //释放节点p
        S->count--;
        return OK;
    }
    ```

  -  时间复杂度：**O(1)**                                                                                                                                                                    



### 4.4.栈的作用与应用

#### 4.4.1.栈的作用

- 栈的引入简化了程序设计的问题，划分了不同的关注层次，使得思考范围缩小，更加聚焦于要解决问题的核心

#### 4.4.2.栈的应用——递归

- 斐波那契数列的实现

  - 数学函数定义

    - $F(n)=\begin{cases}0,&n=0\\1,&n=1\\F(n-1)+F(n-2),&n>1\end{cases}$

  - 递归实现

    - ```c
      //斐波那契数列的递归函数
      int Fib(int i)
      {
          if (i < 2)
          {
              return i == 0 ? 0 : 1;
          }
          return Fib(i - 1) + Fib(i - 2); //调用自己
      }
      ```

    - <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-bef5ad223a0a2b7469035935e130c7e6-14-7f2254.png" alt="1" style="zoom: 40%;" />

- 递归定义
  - 把一个直接调用自己或通过一系列的调用语句简洁的调用自己的函数，称作递归函数
  - 每个递归定义必须至少有一个条件，满足递归不再进行，即不再引用自身而是返回值推出
  - 迭代使用的是循环结构，递归使用的是选择结构
- 栈与递归
  - 递归过程退回的顺序是它前行顺序的逆序；在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据
  - 这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合栈这样的数据结构
  - 简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中；在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态
  - 对于现在的高级语言，这样的递归问题是不需要用户来管理这个栈的，一切都由系统代劳了

#### 4.4.3.栈的应用——四则运算表达式求值

- 后缀表达式：又称逆波兰式（RPN）
  - 所有的符号都是在要运算数字的后面出现
  - 计算（计算）
    - 遇到操作数，直接入栈
    - 遇到运算符，弹出栈顶两个操作数，先有后左进行运算，结果入栈
    - 直至栈空
- 中缀表达式转后缀表达式（机算）
  - 遇到操作数，直接加入后缀表达式
  - 遇到界限符，“`(`”直接入栈，“`)`”则依次弹出栈内运算符并加入后缀表达式，直到弹出“`(`”为止（界限符不加入后缀表达式）
  - 遇到运算符，依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“`(`”或栈空则停止；之后再把当前运算符入栈



### 4.5.队列的定义

- 队列：只允许在云端进行插入操作，而在另一端进行删除操作
  - 队列是一种先进先出（First In First Out）的线性表，简称FIFO
  - 队尾：允许插入的一段
  - 队头：允许删除的一段



### 4.6.队列的顺序存储结构——循环队列

#### 4.6.1.队列顺序存储的不足

- 时间复杂度高：**O(n)**
- 须加指针判断空队：`front`（队头）、`rear`（队尾）

- 可能造成”假溢出“

#### 4.6.2.循环队列

- 循环队列：队列头尾相接的顺序存储结构

  - 队头：`front`；队尾：`rear`

  - 判断队空还是队满

    - 标志变量：`flag`（`front=rear`时，`flag=0`时为队空，`flag=1`时为队满）

    - 保留一个存储空间，防止出现队满时`front=rear`

      - 队列的最大尺寸：`QueueSize`
      - 队满条件：`(rear+1)%QueueSize=front`

      - 队列长度：`(rear-front+QueueSize)%QueueSize`

- 循环队列存储结构代码描述

  - ```c
    //循环队列的顺序存储结构
    typedef struct
    {
        ElemType data[MAXSIZE];
        int front; //头指针
        int rear;  //尾指针，若队列不空，指向队列尾元素的下一个位置
    } SqQueue;
    ```

- 初始化队列

  - `InitQueue(&Q)`：初始化队列

  - ```c
    //初始化队列
    Status InitQueue(SqQueue *Q)
    {
        Q->front = 0;
        Q->rear = 0;
        return OK;
    }
    ```

- 求队长

  - `QueueLength(Q)`：//返回队列元素个数

  - ```c
    //返回队列元素个数
    Status QueueLength(SqQueue Q)
    {
        return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
    }
    ```

- 入队操作

  - `EnQueue(&Q, e)`：若队列未满，则插入元素e为Q新的队尾元素

  - ```c
    //若队列未满，则插入元素e为Q新的队尾元素
    Status EnQueue(SqQueue *Q, ElemType e)
    {
        if ((Q->rear + 1) % MAXSIZE == Q->front)
        { //队列已满
            return ERROR;
        }
        Q->data[Q->rear] = e;              //将元素e赋值给队尾
        Q->rear = (Q->rear + 1) % MAXSIZE; // rear指针向后移一位置，若到最后则转到数组头部
        return OK;
    }
    ```

  - 时间复杂度：**O(1)**          

- 出队操作

  - `DeQueue(&Q, &e)`：若队列不空，则删除Q中队头元素，用e返回其值

  - ```c
    //若队列不空，则删除Q中队头元素，用e返回其值
    Status DeQueue(SqQueue *Q, ElemType *e)
    {
        if (Q->front == Q->rear)
        { //队列已空
            return ERROR;
        }
        *e = Q->data[Q->front];              //将队头元素赋值给e
        Q->front = (Q->front + 1) % MAXSIZE; // front指针向后移一位置，若到最后则转到数组头部
        return OK;
    }
    
    ```

  - 时间复杂度：**O(1)**          



### 4.7.队列的链式存储结构

- 队列的链式存储结构：就是单链表，只不过它只是尾进头出，简称链队列

  - 队头指针（`front`）指向链队列的头结点

  - 队尾指针（`rear`）指向终端结点

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-8ce9e6b12fcf1ab889ff0af3b7b4ea56-15-ce0cf6.png" alt="1" style="zoom: 60%;" />

  - 队列为空时，`front`和`rear`都指向头结点

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-ab53efaff02d7b7f143b6b0e95de6c7c-16-adc42a.png" alt="1" style="zoom: 70%;" />

    

- 链队列存储结构代码描述

  - ```c
    //结点结构
    typedef struct QNode
    {
        ElemType data;
        struct QNode *next;
    } QNode, *QueuePtr;
    //队列的链表结构
    typedef struct
    {
        QueuePtr front, rear; //队头队尾指针
    } LinkQueue;
    ```

- 入队操作

  - `EnQueue(&Q, e)`：插入元素e为Q新的队尾元素

  - ```c
    //插入元素e为Q新的队尾元素
    Status EnQueue(LinkQueue *Q, ElemType e)
    {
        QueuePtr s = (QueuePtr)malloc(sizeof(QNode));
        if (!s)
        { //存储分配失败
            exit(OVERFLOW);
        }
        s->data = e;
        s->next = NULL;
        Q->rear->next = s; //把拥有新元素e的新结点s赋值给原队尾结点的后继
        Q->rear = s;       //把当前的s设置为队尾结点，rear指向s
        return OK;
    }
    ```

  - 时间复杂度：**O(1)**          

- 出队操作

  - `DeQueue(&Q, &e)`：若队列不空，则删除Q中队头元素，用e返回其值

    
  
  - ```c
    //若队列不空，则删除Q中队头元素，用e返回其值
    Status DeQueue(LinkQueue *Q, ElemType *e)
    {
        QueuePtr p;
        if (Q->front == Q->rear)
        { //队列已空
            return ERROR;
        }
        p = Q->front->next; //将欲删除的队头结点暂给p
        *e = p->data;
        ;                         //将欲删除的队头结点的值赋值给e
        Q->front->next = p->next; //将原队头结点后继p->next赋值给头结点后继
        if (Q->rear == p)
        { //若队头是队尾，则删除后将rear指向头结点
            Q->rear = Q->front;
        }
        return OK;
    }
    ```
  
  - 时间复杂度：**O(1)**

-----



## 5.串

### 5.1.串的定义

- 串：有零个或多个字符组成的有限序列，又名字符串

  - 一般记为：s="a_1a_2\dots a_n"(n>=0)s="a_1a_2\dots a_n"(n>=0)；`s`是串的名字，`a`可以是字母、数字或其他字符
  - 串中的字符数目n称为串的长度，零个字符的串称为空串（null string）
  - 串中任意个数的连续字符组成的子序列称为该串的子串，子串在主串的位置就是子串第一个字符在主串的序号

- 串的比较

  - 相等：串的长度相等；对应位置的字符相等
  - 大小：给定两个串，s="a_1a_2\dots a_n",t="b_1b_2\dots b_m"s="a_1a_2\dots a_n",t="b_1b_2\dots b_m"，判s<ts<t，满足以下一个条件即可
    - n<mn<m，且a_i=b_i(i=1,2,\dots,n)a_i=b_i(i=1,2,\dots,n)（即前n项相等），s<ts<t
    - 存在k<=min(m,n)k<=min(m,n)，使得a_i=b_i(i=1,2,\dots,k-1)a_i=b_i(i=1,2,\dots,k-1)，且a_k<b_ka_k<b_k，s<ts<t

- ```c
  // T为非空串，判定T是否为S的子串；若是，返回其在主串的位置
  Status Index(String S, String T, int pos)
  {
      int n, m, i;
      String sub;
      if (pos > 0)
      {
          n = Strlength(S); //得到主串S的长度
          m = Strlength(T); //得到子串T的长度
          i = pos;
          while (i <= n - m + 1)
          {
              SubString(sub, S, i, m); //取出主串第i个位置，长度与T相等子串给sub
              if (StrCompare(sub, T) != 0)
              { //两串不相等
                  ++i;
              }
              else
              {             //两串相等
                  return i; //返回i值
              }
          }
      }
      return 0; //若无子串与T相等，返回0
  }
  ```



### 5.2.串的存储结构

- 串的顺序存储结构
  - 用一组地址连续的存储单元来存储串中的字符序列
  - 按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区；一般用定长数组来定义
  - 常在数组的0下标位置存储串的实际长度，或用`"\0"`来表示字符串的终结
  - 对于串的截取现象，串的存储空间可在程序执行过程中动态分配而得，如利用”堆“
  
  
  
- 串的链式存储结构
  
  - 类似于线性表
  - 为避免空间浪费，一个结点可存放多个字符，未被占满时可用`"#"`代替
  - 串的链式存储除了在连接串与串时方便，总的来说不如顺序存储灵活，性能也不如顺序存储好



### 5.3.朴素的模式匹配算法

- 模式匹配：对子串的定位操作

- 朴素的模式匹配算法
  - 对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配

  - 对主串做大循环，每个字符开头作匹配串长度的小循环

  - 直到匹配成功或遍历结束为止
    - <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-508ebd608b19a448731a9082dd08896f-17-211afe.png" alt="1" style="zoom: 40%;" />
    
      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-fa0a58d0d9e1636822bc598b87a0822a-18-f453b0.png" alt="1" style="zoom: 30%;" /><img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-64e5e1e424a13175fa33f014124518aa-19-4ca0e3.png" alt="1" style="zoom: 30%;" /><img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-6ef4dbdb52f690ca4bac9a728377a798-20-4c618e.png" alt="1" style="zoom: 30%;" />
    
    - <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-123f2ce56dbb1a187ac811d88823d7cc-21-2c5015.png" alt="1" style="zoom: 50%;" />
    
  - `Index(S,T,pos)`：T为非空串，返回子串T在主串S中第pos个字符之后的位置
  
    - ```c
      // T为非空串，返回子串T在主串S中第pos个字符之后的位置
      int Index(String S, String T, int pos)
      {
          int i = pos; // i为主串S中当前位置下标，若pos不为1，则从pos位置开始匹配
          int j = 1;   // j为子串T中当前位置的下标值
          while (i <= S[0] && j <= T[0])
          {
              if (S[i] == T[j])
              {
                  i++;
                  j++;
              }
              else
              {                  //指针后退重新开始匹配
                  i = i - j + 2; // i退回上次匹配首位的下一位
                  j = 1;         // j回到子串T的首位
              }
          }
          if (j > T[0])
          { //若查找成功j=T[0]+1
              return i - T[0];
          }
          else
          {
              return 0;
          }
      }
      ```
  
    - 最好情况：一开始就匹配成功，**O(1)**；如`S="googlegood",T="google"`
  
    - 最坏情况：每次尾字符不匹配，**O((n-m+1)*m)**
  
    - 其他情况：每次首字符不匹配，**O(n+m)**；如`S="abcdegood",T="google"`



### 5.4.KMP模式匹配算法

#### 5.4.1.KMP模式匹配算法原理

- 两种情况

  - 已经比较相等，且与首字母不等

    

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-7a9c9016c1a1554b2bdc88d7c20395e4-22-0a416f.png" alt="1" style="zoom: 100%;" />

    

  - 子串中有与首字符相等的字符

    
  
    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-9028902c9b101aa0fcb5a91fe0a44c6e-23-5019fa.png" alt="1" style="zoom: 100%;" />
  
    
  
  - `i`值不回溯
  
  - `j`值取决于当前字符之前的串的前后缀相似度，与主串无关

#### 5.4.2.next数组

- `next`数组的作用：当模式串的第`j`个字符失配时，从模式串的第`next[j]`的继续往后匹配

- $next[j]=\begin{cases}0,&当j=1时\\Max\{k|1<k<j,且'p_1\dots p_{k-1}'='p_{j-k+1}\dots p_{j-1}'\}&当此集合不空时\\1,&其他情况\end{cases}$

- `next`数组值推导

  - `j`时，求`1`到`j-1`前缀后缀相等串的长度`length`，`next[j]=length+1`

  - | j         | 123456 |
    | --------- | ------ |
    | 模式串T   | abcdex |
    | `next[j]` | 011111 |

  - | j         | 123456 |
    | --------- | ------ |
    | 模式串T   | abcabx |
    | `next[j]` | 011123 |

  - | j         | 123456789 |
    | --------- | --------- |
    | 模式串T   | ababaaaba |
    | `next[j]` | 011234223 |

  - | j         | 123456789 |
    | --------- | --------- |
    | 模式串T   | aaaaaaaab |
    | `next[j]` | 012345678 |

- 获取`next`数组代码

  - `get_next(T,&next)`：通过计算返回子串T的`next`数组

    - ```c
      //通过计算返回子串T的next数组
      void get_next(String T, int *next)
      {
          int i, j;
          i = 1;
          j = 0;
          next[1] = 0;
          while (i < T[0])
          {
              if (j == 0 || T[i] == T[j])
              { // T[i]表示后缀的单个字符，T[j]表示前缀的单个字符
                  i++;
                  j++;
                  next[i] = j;
              }
              else
              {
                  j = next[j]; //若字符不相同，则j值回溯
              }
          }
      }
      ```

    - 时间复杂度：**O(m)**

#### 5.4.3.KMP模式匹配算法实现

- KMP模式匹配算法实现

  - `Index_KMP(S,T,pos)`：T为非空串，返回子串T在主串S中第pos个字符之后的位置

    
    
    - ```c
      // T为非空串，返回子串T在主串S中第pos个字符之后的位置
      int Index_KMP(String S, String T, int pos)
      {
          int i = pos;       // i用于主串S中当前位置下标，若pos不为1，则从pos位置开始匹配
          int j = 1;         // j用于子串T中当前位置的下标值
          int next[255];     //定义一next数组
          get_next(T, next); //对串T做分析，得到next数组
          // O(n)
          while (i <= S[0] && j <= T[0])
          {
              if (j == 0 || S[i] == T[j])
              { //两字符相等则继续，增加了j=0判断
                  i++;
                  j++;
              }
              else
              {                //指针后退重新开始匹配
                  j = next[j]; // j回退到适合的位置，i值不变
              }
          }
          if (j > T[0])
          { //若查找成功j=T[0]+1
              return i - T[0];
          }
          else
          {
              return 0;
          }
      }
      ```
    
    - 时间复杂度：**O(n+m)**

#### 5.4.4.nextval数组

- `next`数组的缺陷

  - `next`数值可能会有大量重复值，比较后不等会反复比较

  - 如`aaaaax`，以下②③④⑤步骤是多余判断

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-3f68c7aa527efadb701f931c706e5de7-24-2ce972.png" alt="1" style="zoom: 40%;" />

  

- 获取`nextval`数组代码

  - `get_nextval(T,&nextval)`：求模式串T的`next`函数修正值并存入数组`nextval`

    - ```c
      //求模式串T的next函数修正值并存入数组nextval
      void get_nextval(String T, int *nextval)
      {
          int i, j;
          i = 1;
          j = 0;
          nextval[1] = 0;
          while (i < T[0])
          {
              if (j == 0 || T[i] == T[j])
              { // T[i]表示后缀的单个字符，T[j]表示前缀的单个字符
                  i++;
                  j++;
                  if (T[i] != T[j])
                  {                   //当前字符与前缀字符不同
                      nextval[i] = j; //则当前的j为nextval在i位置的值
                  }
                  else
                  {                            //当前字符与前缀字符相同
                      nextval[i] = nextval[j]; //字符的nextval值赋值给nextval在i位置的值
                  }
              }
              else
              {
                  j = nextval[j]; //若字符不相同，则j值回溯
              }
          }
      }
      ```
  
- `nextval`数组值推导

  - 当前位置`i`的字符与`next[i]`位置的字符相等，则`nextval[i] = nextval[next[i]]`；不等，则`nextval[i] = next[i]`

  - | j            | 123456789 |
    | ------------ | --------- |
    | 模式串T      | ababaaaba |
    | `next[j]`    | 011234223 |
    | `nextval[j]` | 010104210 |

  - | j            | 123456789 |
    | ------------ | --------- |
    | 模式串T      | aaaaaaaab |
    | `next[j]`    | 012345678 |
    | `nextval[j]` | 000000008 |

-----



## 6.树

### 6.1.树的定义

- 树：是n（n>=0）个结点的有限集

  - n=0时称为空树
  - 在任意一颗非空树中
    - 有且仅有一个特定的称为根（Root）的结点
    - 当n>1时，其余节点可分为m（m>0）个互不相交的有限集$T_1、T_2、\dots 、T_m$，其中每一个集合本身又是一棵树，并且称为根的字数（SubTree）

- 树的结点

  - 结点的度（Degree）：结点拥有的子树个数

  - 结点的分类

    - 根节点：根结点是唯一的
    - 叶子结点（终端结点）：度为0的结点
    - 分支结点（非终端结点）：度不为0的结点
    - 内部结点：除根结点外的分支结点

  - 树的度：树内各结点度的最大值

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-f55e1b39b454f9d4b86760bc1802fdfd-25-761d38.png" alt="1" style="zoom: 40%;" />

  - 结点间关系

    - 结点子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）

    - 同一个双亲的孩子之间互称兄弟（Sibling）

    - 结点的祖先是从根到该结点所经分支上的所有结点

    - 以某结点为根的子树中的任一结点都称为该结点的子孙

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-3830f15b16a0392a86133b3a0cacd79b-26-316465.png" alt="1" style="zoom: 40%;" />

- 树的其他相关概念

  - 结点的层次（Level）从根结点开始定义起，根为第一层，根的孩子为第二层
  - 双亲在同一层的结点互为堂兄弟
  - 树中结点的最大层次称为树的深度（Depth）或高度
  - 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树
  - 森林（Forest）是m（m>=0）棵互不相交的树的集合

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-0b44c8db6ac3ce7762d9dab33ef8cf4b-27-659638.png" alt="1" style="zoom: 40%;" />

  

### 6.2.树的存储结构

<img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-330625009ec36b5d7aad452d7049c688-28-372fa8.png" alt="1" style="zoom: 50%;" />

#### 6.2.1.双亲表示法

- 双亲表示法：假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置

  | data | parent |
  | ---- | ------ |

  - data：数据域；存储结点的数据信息
  - parent：指针域；存储该结点的双亲在数组中的下标（根节点：没有双亲，指针域设置为-1）
  
  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-16673b3a173606b51f72e012ba935cde-29-58b12a.png" alt="1" style="zoom: 50%;" />



- 双亲表示法的结点结构定义代码描述

  - ```c
    //树的双亲表示法结点结构定义
    //结点结构
    typedef struct PTNode
    {
        ElemType data; //结点数据
        int parent;    //双亲位置
    } PTNode;
    //树结构
    typedef struct
    {
        PTNode nodes[MAXSIZE]; //结点数组
        int r, n;              //根的位置和结点数
    } PTree;
    ```

  - 可增添长子域

#### 6.2.2.孩子表示法

- 多重链表表示法：每个结点有多个指针域，其中每个指针指向一棵子树的根结点
  - 方法一：指针域个数等于树的度
  - 方法二：指针域个数等于该结点的度

- 孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此链表为空；然后n个指针域组成一个线性表，采用顺序存储结构，存放进一个一维数组中

  - 孩子链表的孩子结点

    | child | next |
    | ----- | ---- |

    - child：数据域；用来存储某个结点在表头数组中的下标
    - next：指针域；用来存储指向某结点的下一个孩子结点的指针

  - 表头数组的表头结点

    | data | firstchild |
    | ---- | ---------- |

    - data：数据域；存储结点的数据信息
    - firstchild：头指针域；存储该结点的孩子链表的头指针

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-cc7b7e464043545a97a353c6c8bb03ec-30-4a9e36.png" alt="1" style="zoom: 45%;" />

  

- 孩子表示法的结点结构定义代码描述

  - ```c
    //树的孩子表示法结点结构定义
    //孩子结点
    typedef struct CTNode
    {
        int child;
        struct CTNode *next;
    } * ChildPtr;
    //表头结构
    typedef struct
    {
        ElemType data;
        ChildPtr firstchild;
    } CTBox;
    //树结构
    typedef struct
    {
        CTBox nodes[MAXSIZE]; //结点数组
        int r, n;             //根的位置和结点数
    } CTree;
    ```

#### 6.2.3.孩子兄弟表示法

- 孩子兄弟表示法：任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的；因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟

  | data | firstchild | rightchild |
  | ---- | ---------- | ---------- |

  - data：数据域；存储结点的数据信息

  - firstchild：指针域；存储该结点的第一个孩子结点的存储地址

  - rightchild：指针域；存储该结点的右兄弟结点的存储地址

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-f7114bd5ad1659f60517819205c5ad94-31-2979ee.png" alt="1" style="zoom: 60%;" />



- 孩子兄弟表示法的结点结构定义代码描述

  - ```c
    //树的孩子兄弟表示法结点结构定义
    typedef struct CSNode
    {
        ElemType data;
        struct CSNode *firstchild, *rightsib;
    } CSNode, *CSTree;
    ```



### 6.3.二叉树

#### 6.3.1.二叉树的定义

- 二叉树（Binary Tree）：是n（n>=0）个结点的有限集合
  - 集合为空集：空二叉树
  - 集合不为空集：由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成
- 二叉树的特点
  - 每个结点最多有两个子树，即二叉树中结点的度不大于2（0<=D<sub>度</sub><=2）
  - 左子树和右子树是有序的，不能颠倒
  - 即使树中某结点只有一棵子树，也要区分左子树和右子树
- 二叉树的五种形态
  - 空二叉树
  - 只有一个根结点
  - 根结点只有左子树
  - 根结点只有右子树
  - 根结点既有左子树又有右子树
- 特殊二叉树
  - 斜树
    - 左斜树：所有的结点都只有左子树的二叉树
    - 右斜树：所有的结点都只有右子树的二叉树
    - 左斜树和右斜树统称为斜树
  - 满二叉树
    - 满二叉树：所有分支结点都存在左子树和右子树，且所有叶子结点都在同一层
    - 特点
      - 叶子结点只能出现在最下一层
      - 非叶子结点的度一定是2
      - 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多
  - 完全二叉树
    - 完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为`i`（1<=i<=n）的结点与同样深度的满二叉树中编号为`i`的结点在二叉树中位置完全相同
    - 特点
      - 叶子结点只能出现在最下两层
      - 最下层的叶子一定集中在左部连续位置
      - 倒数第二层，若有叶子结点，一定都在右部连续位置
      - 如果结点的度为1，则该结点只有左孩子，即不存在只有右孩子树的情况
      - 同样结点树的二叉树，完全二叉树的深度最小

#### 6.3.2.二叉树的性质

- 性质1： 在二叉树的第`i`层上至多有2i−12^{i-1}个结点
- 性质2：深度为`k`的二叉树至多有2k−12^{k}-1个结点（k>=1）
- 性质3：对任何一棵二叉树T，如果叶子结点数为n0n_{0}，度为2的结点数n2n_{2}，则n0=n2+1n_{0}=n_{2}+1
  - 度为1的结点数n1n_{1}，结点总数为nn
  - n=n0+n1+n2n=n_{0}+n_{1}+n_{2}
  - 分支线总数=n−1=n1+2n2分支线总数=n-1=n_{1}+2n_{2}
  - 推导得n0=n2+1n_{0}=n_{2}+1
- 性质4：具有n个结点的完全二叉树的深度为⌊log2n+1⌋(⌊x⌋表示不大于x的最大整数)\left \lfloor log_2n+1\right \rfloor(\left \lfloor x\right \rfloor表示不大于x的最大整数)
  - 深度kk，则结点数2k−1−1<n<=2k−12^{k-1}-1<n<=2^{k}-1
  - 则2k−1<=n<2k2^{k-1}<=n<2^{k}，取对数得k−1<=log2n<kk-1<=log_2n<k
  - 推导得k=⌊log2n+1⌋k=\left \lfloor log_2n+1\right \rfloor
- 性质5：如果对一棵有n个结点的完全二叉树（深度k=⌊log2n+1⌋k=\left \lfloor log_2n+1\right \rfloor）的结点按层编号（从第1层到第⌊log2n+1⌋\left \lfloor log_2n+1\right \rfloor层，每层从左到右），对任一结点`i`（1<=`i`<=n）有
  - 如果`i=1`，则结点`i`是二叉树的根，无双亲；如果`i>1`，则其双亲是结点⌊i/2⌋\left \lfloor i/2\right \rfloor
  - 如果`2i>n`，则结点`i`无左孩子（结点`i`为叶子结点）；否则其左孩子是结点`2i`
  - 如果`2i+1>n`，则结点`i`无右孩子（结点`i`为叶子结点）；否则其右孩子是结点`2i+1`

#### 6.3.3.二叉树的存储结构

- 二叉树的顺序存储结构

  - 用一维数组存储二叉树的结点
  - 顺序存储结构一般仅用于完全二叉树

- 二叉链表

  - 二叉链表：一个数据域和两个指针域

    | lchild | data | rchild |
    | ------ | ---- | ------ |

    - data：数据域
    - lchild、rchild：指针域；存放指向左、右孩子的指针

- 二叉链表结点结构定义代码描述

  - ```c
    //二叉树的二叉链表结点结构定义
    //结点结构
    typedef struct BiTNode
    {
        ElemType data;                   //结点数据
        struct BiTNode *lchild, *rchild; //左右孩子指针
    } BiTNode, *BiTree;
    ```

#### 6.3.4.遍历二叉树

- 二叉树的遍历（traversing binary tree）：指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次
  - 关键词：访问、次序

  

- 二叉树遍历的方法
  - 前序遍历
    - 规则：若二叉树为空，则空操作返回，否则访问根结点，然后前序遍历左子树，再前序遍历右子树
    - <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-997b1563865322553b17031dfdccb1a9-32-303cbe.png" alt="1" style="zoom: 40%;"/>
    - 遍历结果：**ABDGHCEIF**
  - 中序遍历
    - 规则：若二叉树为空，则空操作返回，否则从根节点开始（并不是先访问根结点），中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树
    - <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-43c3a6744620b9a9ab483fad6b0ee6a1-33-05fd65.png" alt="1" style="zoom: 40%;"/>
    - 遍历结果：**GDHBAEICF**
  - 后序遍历
    - 规则：若二叉树为空，则空操作返回，否则从左到右先叶子结点后分支结点的方式遍历访问左右，最后访问根结点
    - <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-ce123cc5de9634f66ac6732e2a95bf2a-34-bb10ab.png" alt="1" style="zoom: 40%;"/>
    - 遍历结果：**GHDBIEFCA**

  

  - 层序遍历
    - 规则：若二叉树为空，则空操作返回，否则从树的第一层（即根结点），从上而下开始遍历，在同一层中，按从左到右的顺序对结点逐个访问
    - <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-f12a2f98be8c915dfcadd13381b95d82-35-edee98.png" alt="1" style="zoom: 40%;"/>
    - 遍历结果：**ABCDEFGHI**

- 前序遍历算法

  - `PreOrderTraverse(T)`：二叉树的前序遍历递归算法

    - ```c
      //二叉树的前序遍历递归算法
      void PreOrderTraverse(BiTree T)
      {
          if (T == NULL)
          {
              return;
          }
          printf("%c", T->data);       //显示结点数据，可更改为其他操作
          PreOrderTraverse(T->lchild); //再先序遍历左子树
          PreOrderTraverse(T->rchild); //最后先序遍历右子树
      }
      ```

- 中序遍历算法

  - `InOrderTraverse(T)`：二叉树的中序遍历递归算法

    - ```c
      //二叉树的中序遍历递归算法
      void InOrderTraverse(BiTree T)
      {
          if (T == NULL)
          {
              return;
          }
          InOrderTraverse(T->lchild); //中序遍历左子树
          printf("%c", T->data);      //显示结点数据，可更改为其他操作
          InOrderTraverse(T->rchild); //最后中序遍历右子树
      }
      ```



- 后续遍历算法

  - `PostOrderTraverse(T)`：二叉树的后序遍历递归算法

    - ```c
      //二叉树的后序遍历递归算法
      void PostOrderTraverse(BiTree T)
      {
          if (T == NULL)
          {
              return;
          }
          PostOrderTraverse(T->lchild); //先后序遍历左子树
          PostOrderTraverse(T->rchild); //再后序遍历右子树
          printf("%c", T->data);        //显示结点数据，可更改为其他操作
      }
      ```

- 推导遍历结果
  - 确定一棵二叉树
    - 已知前序遍历序列和中序遍历序列
    - 已知后序遍历序列和中序遍历序列
  - 推导方法
    - 已知前序和中序
      - 前序遍历序列的首字母即为根结点
      - 中序遍历序列中根结点左侧字母为根结点左子树的结点，根结点右侧字母为根结点右子树的结点
      - 前序遍历序列确定每一层根结点，中序遍历序列确定该根结点有无孩子结点
      - 依次按层推导
      - 示例：前序遍历序列为**ABCDEF**，中序遍历序列为**CBAEDF**
        - <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-02c52d558c752ced75df03078e65c528-36-5d675e.png" alt="1" style="zoom: 40%;"/>
        - <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-a6483d74bb2a9116886576bb9b5b0b32-37-c3ba1b.png" alt="1" style="zoom: 40%;"/>
        - <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-75da177a21d3ef6a7a99487aec598e9c-38-50bfb2.png" alt="1" style="zoom: 40%;"/>
    - 已知后序和中序
      - 推导和上述方法基本相同，区别在于后序遍历尾字母为根结点

#### 6.3.5.二叉树的建立

- 扩展二叉树：为确立每个结点是否有左右孩子，每个结点的空指针引出一个虚结点，其值可以设为特定值（如'#'），该树即为原二叉树的扩展二叉树；扩展二叉树遍历一次即可确定一棵二叉树

  - 示例：前序遍历序列**AB#D##C##**

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-d8e73f2882fbbd813df49efda02a2c2e-39-5b15f5.png" alt="1" style="zoom: 60%;"/>

- 二叉树建立算法

  - `CreateBiTree(&T)`：按前序遍历输入二叉树中结点的值（一个字符）

    - ```c
      void CreateBiTree(BiTree *T)
      {
          ElemType ch;
          scanf("%c", &ch);
          if (ch == '#')
          {
              *T = NULL;
          }
          else
          {
              *T = (BiTree)malloc(sizeof(BiTNode));
              if (!*T)
              {
                  exit(OVERFLOW); //越界溢出
              }
              (*T)->data = ch;             //生成根结点
              CreateBiTree(&(*T)->lchild); //构造左子树
              CreateBiTree(&(*T)->rchild); //构造右子树
          }
      }
      ```



### 6.4.线索二叉树

#### 6.4.1.线索二叉树原理

- 建立线索二叉树的原因

  - 二叉树中有很多的空指针域未被利用（n个结点有n+1个空指针域）
  - 不进行遍历，无法得知每个结点的前驱和后继

- 线索二叉树（Threaded Binary Tree）

  - 定义：指向前驱和后继的指针称为线索，加上线索的二叉链表为线索链表，相应的二叉树为线索二叉树

  - 线索化：对二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化

    - 结点空指针域中的右指针改为指向该结点的后继结点

    - 结点空指针域中的左指针改为指向该结点的前驱结点

    - 结点无前驱或后继，空指针指向`NULL`

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-23f0dbea8e9257e4e7c04059c8427ff5-40-647e2d.png" alt="1" style="zoom: 40%;"/>

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-56eaa44bd4bbb5b7b761ae56bfcbf520-41-41a669.png" alt="1" style="zoom: 40%;"/>

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-c07a2f5b107d1851debb6f6c5eda711e-42-afbaed.png" alt="1" style="zoom: 40%;"/>

  - 标志域

    - 标志域用于区分指针指向的是左右孩子结点还是前驱后继结点

    - 结点结构

      | lchild | ltag | data | rtag | rchild |
      | ------ | ---- | ---- | ---- | ------ |

      - `ltag`为0时指向该结点的左孩子，为1时指向该结点的前驱
      - `rtag`为0时指向该结点的右孩子，为1时指向该结点的后继

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-214d43ce8c227e0df2e38aa17ae69b14-43-67fee5.png" alt="1" style="zoom: 40%;"/>

#### 6.4.2.线索二叉树结构实现

- 二叉树的线索存储结构定义代码描述

  - ```c
    //二叉树的二叉线索存储结构定义
    typedef enum
    {
        Link,
        Thread
    } PointerTag; // Link=0，表示指向左右孩子指针
                  // Thread=1，表示指向前驱或后继的线索
    typedef struct BiThrNode
    {
        ElemType data;                     //结点数据
        struct BiThrNode *lchild, *rchild; //左右孩子指针
        PointerTag LTag;
        PointerTag RTag; //左右标志
    } BiThrNode, *BiThrTree;
    ```

- 中序遍历线索化

  - 线索化的过程就是在遍历的过程中修改空指针的过程

  - `InThreading(p)`：中序遍历进行中序线索化

    - ```c
      BiThrTree pre; //全局变量，始终指向刚刚访问过的结点
      //中序遍历进行中序线索化
      void InThreading(BiThrTree p)
      {
          if (p)
          {
              InThreading(p->lchild); //递归左子树线索化
              if (!p->lchild)
              {                     //没有左孩子
                  p->LTag = Thread; //前去线索
                  p->lchild = pre;  //左孩子指针指向前驱
              }
              if (!pre->rchild)
              {                       //前驱没有右孩子
                  pre->RTag = Thread; //后继线索
                  pre->rchild = p;    //前驱右孩子指针指向后继（当前结点p）
              }
              pre = p;                //保持pre指向p的前驱
              InThreading(p->rchild); //递归右子树线索化
          }
      }
      ```

      - `if (!p->lchild)`：`p`左指针域为空，前驱结点刚被访问，且赋值给了`pre`；将前驱结点赋值给空的左指针域（`p->lchild = pre`），并修改标志域（`p->LTag = Thread`）

      - `if (!pre->rchild)`：`p`结点的后继还没被访问到，此时只能对前驱结点`pre`的右指针进行判断；`pre`右指针域为空，则`p`就是`pre`的后继结点；将当前结点赋值给前驱空的右指针域（`pre->rchild = p`），并修改标志域（`pre->RTag = Thread`）

      - 二叉线索链表需添加一个头结点，头结点的左指针指向根结点，右指针指向中序遍历最后一个结点，中序遍历第一个结点的左指针和最后一个结点的右指针均指向头结点；由此我们既可以从第一个结点顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历

        <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-eea607e308de4947649b426b98b56a9e-44-e46aa3.png" alt="1" style="zoom: 40%;"/>

- 中序线索二叉树遍历

  - `InOrderTraverse_Thr(T)`：

    - ```c
      //中序遍历中序线索二叉树
      Status InOrderTraverse_Thr(BiThrTree T)
      {
          BiThrTree p;
          p = T->lchild; // p指向根结点
          while (p != T)
          { //空树或遍历结束时，p==T
              while (p->LTag == Link)
              { //当LTag==0时循环到中序序列的第一个结点
                  p = p->lchild;
              }
              printf("%c", p->data); //显示结点数据，可更改为其他操作
              while (p->RTag == Thread && p->rchild != T)
              {
                  p = p->rchild;
                  printf("%c", p->data);
              }
              p = p->rchild; // p进至其右子树根
          }
          return OK;
      }
      ```

      - 时间复杂度：**O(n)**



### 6.5.树和森林与二叉树的转换

- 树转换为二叉树

  - 加线：在所有兄弟结点之间加一条连线

  - 去线：对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线

  - 层次调整：以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明；第一个孩子是二叉树的左孩子，兄弟转换过来是二叉树的右孩子

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-9d8298250f412cdab4399bf30a0680da-45-82c27c.png" alt="1" style="zoom: 80%;"/>

- 森林转换为二叉树

  - 把每棵树转换为二叉树

  - 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵树的根结点的右孩子，用线连接起来

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-56c1e3bdcdeb5a3eb1d215cd11e3c3da-46-f9cf9d.png" alt="1" style="zoom: 80%;"/>

- 二叉树转换为树

  - 加线：若某结点有左孩子结点，左孩子的n个右孩子结点都作为该结点的孩子；将该结点与这些右孩子结点连接起来

  - 去线：删除原二叉树中所有结点与其右孩子结点的连线

  - 层次调整：使之结构层次分明

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-14472631735f3b42ddcb07e0c09e27cd-47-1a3df6.png" alt="1" style="zoom: 80%;"/>

- 二叉树转换为森林

  - 判断二叉树是否可以转换为森林：根结点是否有右孩子，有则可转化为森林，反之不可

  - 从根结点开始，若右孩子存在，把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，把与右孩子结点的连线删除······，直到所有右孩子连线都删除为止

  - 将每个分离后的二叉树转换为树

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-a3147e3d1187a4606efc9d8fec06c1ca-48-00d873.png" alt="1" style="zoom: 80%;"/>

  

- 树与森林的遍历

  - 树的遍历
    - 先根遍历：先访问树的根结点，再依次先跟遍历每棵子树
    - 后根遍历：先依次后跟遍历每棵子树，再访问树的根结点
    - 示例
      - <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-267e5920e215e461193db24b8ee2f8f4-49-41884b.png" alt="1" style="zoom: 40%;"/>
      - 先根遍历：**ABEFCDG**；后根遍历：**EFBCGDA**
  - 森林的遍历
    - 前序遍历：从第一棵树开始，依次先根遍历每棵树
    - 后序遍历：从第一棵树开始，依次后根遍历每棵树
    - 示例
      - <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-3016946ca7ee073e40055a205c080f48-50-c51a93.png" alt="1" style="zoom: 40%;"/>
      - 前序遍历：**ABCDEFGHJI**；后序遍历：**BCDAFEJHIG**



### 6.6.赫夫曼树及其应用

- 赫夫曼树定义与原理

  - 路径长度：从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度
  - 树的路径长度：从树根到每一结点的路径长度之和
  - 带权路径长度：该结点到树根之间的路径长度与结点上权的乘积
  - 树的带权路径长度：所有叶子结点的带权路径长度之和
  - **赫夫曼树（最优二叉树）：带权路径长度WPL最小的二叉树**

- 赫夫曼树的构造

  - 算法描述

    - 给定的n个权值$\{w_1,w_2,\dots,w_n\}$构成n棵二叉树的集合$F=\{T_1,T_2,\dots,T_n\}$，其中每棵二叉树$T_i$中只有一个带权为$w_i$的根结点，左右子树均为空
    - 在$F$中选取两棵根结点权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和
    - 在$F$中删除这两棵树，同时将新得到的二叉树加入$F$中
    - 重复前两步，直到$F$中只含一棵树为止；这棵树便是赫夫曼树

  - 示例

    - $F=\{A5,E10,B15,D30,C40\}$

    - $F=\{N_115,B15,D30,C40\}$；$F=\{N_230,D30,C40\}$；$F=\{C40,N_360\}$

    - $F=\{T\}$

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-88fd234f1e321f9e7982515c70c8cd36-51-9e1ea2.png" alt="1" style="zoom: 40%;"/>

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-cb9e73b8bac66564dd6c4772ef9f9f84-52-72c0b8.png" alt="1" style="zoom: 40%;"/>

    - $WPL=40*1+30*2+15*3+10*4+5*4=205$

- 赫夫曼编码

  - 赫夫曼编码

    - 设需要编码的字符集为$\{d_1,d_2,\dots,d_n\}$，各个字符在电文中出现的次数或频率为$\{w_1,w_2,\dots,w_n\}$，以$d_1,d_2,\dots,d_n$作为叶子结点，以$w_1,w_2,\dots,w_n$作为相应叶子结点的权值来构造一棵赫夫曼树
    - 规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1序列便为该结点对应字符的编码，这就是赫夫曼编码

  - 解码：解码时按照赫夫曼树进行解码，且该树具有同样的赫夫曼编码规则

  - 示例

    - $F=\{A27,B8,C15,D15,E30,F5\}$

    - 构造赫夫曼树

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-005ecf37ec0ca64ac0d1fb1acdd37ec3-53-769893.png" alt="1" style="zoom: 80%;"/>

    - 赫夫曼编码（左子树为0，右子树为1）

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-2f4864b793d54831e803eab108c7862f-54-d266e6.png" alt="1" style="zoom: 80%;"/>

      | 字母           | A      | B        | C       | D      | E      | F        |
      | -------------- | ------ | -------- | ------- | ------ | ------ | -------- |
      | **二进制字符** | **01** | **1001** | **101** | **00** | **11** | **1000** |

    - 解码（10010100101）：**BADC**

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-2db8a61fed5fa58d10cbe416d07b5aaa-55-95b23b.png" alt="1" style="zoom: 80%;"/>

----



## 7.图

### 7.1.图的定义

#### 7.1.1.图的定义

- 图（Graph）：由顶点的有穷非空集合和顶点之间边的集合组成
  - 通常记为：`G(V,E)`
  - `G`表示一个图，`V`是图`G`中顶点的集合，`E`是图`G`中边的集合
  - 图中的数据元素称为顶点（Vertex）
  - 不允许图中没有顶点，即`V`不能是空集
  - 图中任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边表示，边集可以为空

#### 7.1.2.图的概念及分类

- 无向边：若顶点$v_i$到$v_j$之间的边没有方向，则称这条边为无向边（Edge），用无序偶对$(v_i,v_j)$表示

- 无向图：图中任意两个顶点之间的边都是无向边，则称该图为无向图（Undirected graphs）

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-612cf176d7082d7e45fae6a8afbcb79c-56-102f67.png" alt="1" style="zoom: 40%;"/>

- 有向边：若从顶点$v_i$到$v_j$之间的边有方向，则称这条边为有向边，也成为弧（Arc），用有序偶$<v_i,v_j>$表示；$v_i$称为弧尾（Tail），$v_j$称为弧头（Head），头尾是有序的，不能调换

- 有向图：图中任意两个顶点之间的边都是有向边，则称该图为有向图（Directed graphs）

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-2206ed0fa7add22cdf4f188ae4e38b37-57-f4c791.png" alt="1" style="zoom: 40%;"/>

- 简单图：在图中，若不存在定点到其自身的边，且同一条边不重复出现，则称这样的图为简单图

- 无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图；n个顶点的无向完全图有$\frac{n*(n-1)}{2}$条边

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-58a8a9a6aa37525c19abce383ee35709-58-a63ab2.png" alt="1" style="zoom: 40%;"/>

- 有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图；n个顶点的有向完全图有$n*(n-1)$条边

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-3b9bd1f05fe81a99fda0ae85c642d172-59-f4639f.png" alt="1" style="zoom: 40%;"/>

- 稀疏图：有很少条边或弧的图称为稀疏图，反之称为稠密图

- 权：图的边或弧具有与它相关的数字，这种与图的边或弧相关的数字称为权（Weight）

- 网：带权的图通常称为网（Network）

- 子图：假设有两个图$G=(V,\{E\})$和$G^{'}=(V^{'},\{E^{'}\})$，如果$V^{'}\subseteq V$且$E^{'}\subseteq E$，则称$G^{'}$为$G$的子图（Subgraph）

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-49beaed43768d0f745e235343ad5883a-60-0f93ed.png" alt="1" style="zoom: 60%;"/>


#### 7.1.3.图的顶点与边

- 顶点与边

  - 无向图$G=(V,\{E\})$，边$(v,v^{'})\in E$
    - 顶点$v$与$v^{'}$互为邻接点（Adjacent），即$v$与$v^{'}$相邻接
    - 边$(v,v^{'})$依附于顶点$v$和$v^{'}$，或者说边$(v,v^{'})$与顶点$v$和$v^{'}$相关联
    - 顶点$v$的度（Degree）是和$v$相关联的边的数目，记为$TD(v)$
    - 边数$e=\frac{1}{2}\sum_{i=1}^{n}TD(v_i)$

  - 有向图$G=(V,\{E\})$，弧$<v,v^{'}>\in E$
    - 顶点$v$邻接到顶点$v^{'}$，顶点$v^{'}$邻接自顶点$v$
    - 弧$<v,v^{'}>$和顶点$v，v^{'}$相关联
    - 以顶点$v$为头的弧的数目称为$v$的入度（InDegree），记为$ID(v)$
    - 以顶点$v$为尾的弧的数目称为$v$的出度（OutDegree），记为$OD(v)$
    - 顶点$v$的度为$TD(v)=ID(v)+OD(v)$
    - 边数$e=\sum_{i=1}^{n}ID(v_i)=\sum_{i=1}^{n}OD(v_i)$

- 路径

  - 无向图$G=(V,\{E\})$中，从顶点$v$到$v^{'}$的路径（Path）是一个顶点序列$(v=v_{i,0},v_{i,1},\dots,v_{i,m})$，其中$(v_{i,j-1},v_{i,j})\in E,1<=j<=m$

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-2f418f5c3cb0e9fdd02320f47fe1626c-61-7f024f.png" alt="1" style="zoom: 40%;"/>

  - 有向图$G=(V,\{E\})$，则路径是有向的，顶点序列满足$<v_{i,j-1},v_{i,j}>\in E,1<=j<=m$

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-06587dcced9bf2606b0093e3d3c3b81c-62-9ceba4.png" alt="1" style="zoom: 40%;"/>

  - 路径的长度是路径上的边或弧的数目

- 简单回路

  - 回路：第一个顶点到最后一个顶点相同的路径称为回路或环（Cycle）

  - 简单路径：序列中顶点不重复出现的路径称为简单路径

  - 简单回路：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-6d164a49454cc804928a797636894ead-63-d92c58.png" alt="1" style="zoom: 40%;"/>


#### 7.1.4.连通图

- 连通图

  - 无向图GG

    - 如果从顶点vv到顶点v′v_{'}有路径，则称vv和v′v_{'}是连通的

    - 如果对于图中任意两个顶点vi,vj∈Vv_i,v_j\in V，viv_i和vjv_j都是连通的，则称GG是连通图

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-0a622c16ffadc756a4ac9296f1e8fad9-64-4f6fc6.png" alt="1" style="zoom: 40%;"/>

      - 图2是连通图，图1不是

    - 无向图中的极大连通子图称为连通分量

      - 要是子图且子图连通
      - 连通子图含有极大定点数（再多一个顶点则不是连通图）
      - 连通子图中包含依附于所有顶点的边（子图中顶点的边与原图中该顶点的边的边数一致）

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-0a622c16ffadc756a4ac9296f1e8fad9-64-4f6fc6.png" alt="1" style="zoom: 40%;"/>

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-866d3d3448120af5e031bef59e517938-65-c855d4.png" alt="1" style="zoom: 40%;"/>

      - 图2和图3是图1的连通分量，图4不是

  - 有向图GG

    - 如果对于每一对vi,vj∈V,vi≠vjv_i,v_j\in V,v_i\neq v_j，从viv_i到vjv_j和从vjv_j到viv_i都存在路径，则称GG是强连通图

    - 有向图中的极大连通子图称作有向图的强连通分量

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-39b8d158984fd09c951608b863495edf-66-2de701.png" alt="1" style="zoom: 40%;"/>

      - 图2是强连通图，图1不是
      - 图2是图1的强连通分量

- 连通图的生成树

  - 一个无向连通图的生成树是一个极小连通子图，它含有图中全部的`n`个顶点，但只有足以构成一棵树的`n-1`条边

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-2760300227a76a6bf4865278dfe752a4-67-b95bc0.png" alt="1" style="zoom: 40%;"/>

    - 图2和图3是图1的生成树，图4不是

  - 如果一个有向图恰有一个顶点入度为0，其余顶点入度均为1，则是一棵有向树

  - 一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-f8211a2631c66288999660ded8d237fd-68-2f004c.png" alt="1" style="zoom: 40%;"/>

    - 图2和图3是图1的生成森林



### 7.2.图的存储结构

#### 7.2.1.邻接矩阵

- 图的邻接矩阵（Adjacency Matrix）：存储方式是两个数组来表示图；一个一维数组存储图中的顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息

  - 设图GG有nn个顶点，则邻接矩阵是一个n∗nn*n的方阵

    $arc[i][j]=\begin{cases}1,&若(v_i,v_j)\in E或<v_i,v_j> \in E\\0,&反之\end{cases}$

    

    - 示例（无向图）

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-7312923960b9f19721dd979c3a9eaeef-69-32a8d0.png" alt="1" style="zoom: 40%;"/>

      - 无向图的边数组是对称矩阵
      - 顶点的度（viv_i）：顶点viv_i在邻接矩阵第ii行（或第ii列）的元素之和
      - 顶点的邻接点（viv_i）：将邻接矩阵第ii行元素扫描一遍，$arc[i][j]$为1就是邻接点

    - 示例（有向图）

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-2321efccf48bfa73e649a7f710489d06-70-cd566a.png" alt="1" style="zoom: 40%;"/>

      - 顶点的度（viv_i）：viv_i的入度为第ii列各数之和，viv_i的出度为第ii行各数之和
      - 顶点的邻接点（viv_i）：将邻接矩阵第ii行元素扫描一遍，$arc[i][j]$为1就是邻接点

  - 设图GG是网图，有nn个顶点，则邻接矩阵是一个n∗nn*n的方阵

    $arc[i][j]=\begin{cases}W_{ij},&若(v_i,v_j)\in E或<v_i,v_j> \in E\\0,&当i=j\\\infin,&反之\end{cases}$

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-63ef8101aa2142612f0da6ffd7aff3c2-71-5beecc.png" alt="1" style="zoom: 40%;"/>



- 邻接矩阵存储结构定义代码描述

  - ```c
    typedef char VertexType; //顶点类型
    typedef int EdgeType;    //边上权值类型
    #define MAXVEX 100       //最大顶点数
    #define INFINITY 65535   //用65535表示无穷
    
    typedef struct
    {
        VertexType vexs[MAXVEX];      //顶点表
        EdgeType arc[MAXVEX][MAXVEX]; //邻接矩阵
        int numVertexes, numEdges;    //图中当前顶点数和边数
    } MGraph;
    ```

- 创建邻接矩阵

  - `CreateMGraph(&G)`：建立无向图的邻接矩阵表示

    - ```c
      //建立无向图的邻接矩阵表示
      void CreateMGraph(MGraph *G)
      {
          int i, j, k, w;
          printf("输入顶点数和边数:\n");
          scanf("%d,%d", &G->numVertexes, G->numEdges); //输入顶点数和边数
          for (i = 0; i < G->numVertexes; i++)
          { //读入顶点信息，建立顶点表
              scanf(&G->vexs);
          }
          for (i = 0; i < G->numVertexes; i++)
          {
              for (j = 0; j < G->numVertexes; j++)
              {
                  G->arc[i][j] = INFINITY; //邻接矩阵初始化
              }
          }
          for (k = 0; k < G->numEdges; k++)
          { //读入numEdges条边，建立邻接矩阵
              printf("输入边(vi,vj)上的下标i，下标j和权w:\n");
              scanf("%d,%d,%d", &i, &j, &w); //输入边(vi,vj)和边上的权
              G->arc[i][j] = w;
              G->arc[j][i] = G->arc[i][j]; //无向图，矩阵对称
          }
      }
      ```

#### 7.2.2.邻接表

- 邻接表（Adjacency List）：数组与链表相结合；图中顶点用一个一维数组存储，每个数据元素存储顶点信息和指向第一个邻接点的指针；图中每个顶点$v_i$的所有邻接点构成一个线性表，用单链表存储，无向图称为顶点$v_i$的边表，有向图称为顶点$v_i$作为弧尾的出边表

  - 顶点表结构

    | data | firstedge |
    | ---- | --------- |

    - data：数据域，存储定点信息
    - firstedge：指针域，指向边表第一个结点

  - 边表结构

    | adjvex | next |
    | ------ | ---- |

    - adjvex：邻接点域，存储某顶点的邻接点在顶点表中的下标

    - next：指针域，指向边表下一个结点

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-79d307f5c6304b555a383734961176e4-72-ad7f60.png" alt="1" style="zoom: 40%;"/>

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-c3b39c72d0e780b5e4e38592aa9a2c37-73-7bb8e7.png" alt="1" style="zoom: 40%;"/>

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-0b9dafe4e67844646dfa77ba3bb2c62d-74-f15bac.png" alt="1" style="zoom: 40%;"/>

- 邻接表存储结构定义代码描述

  - ```c
    //边表结点
    typedef struct EdgeNode
    {
        int adjvex;            //邻接点域，存储该顶点对应的下标
        EdgeType weight;       //用于存储权值
        struct EdgeNode *next; //链域，指向下一个邻接点
    } EdgeNode;
    //顶点表结点
    typedef struct VertexNode
    {
        VertexType data;     //顶点域，存储顶点信息
        EdgeNode *firstedge; //边表头指针
    } VertexNode, AdjList[MAXVEX];
    //邻接表
    typedef struct
    {
        AdjList adjlist;
        int numVertexes, numEdges; //图中当前顶点数和边数
    } GraphAdjList;
    ```

  

- 创建邻接表

  - `CreateALGraph(&G)`：建立图的邻接表结构

    - ```c
      //建立图的邻接表结构
      void CreateALGraph(GraphAdjList *G)
      {
          int i, j, k;
          EdgeNode *e;
          printf("输入顶点数和边数:\n");
          scanf("%d,%d", &G->numVertexes, &G->numEdges); //输入顶点数和边数
          for (i = 0; i < G->numVertexes; i++)
          {
              scanf(&G->adjlist[i].data);     //输入顶点信息
              G->adjlist[i].firstedge = NULL; //将边表置空
          }
          for (k = 0; k < G->numEdges; k++)
          { //建立边表
              printf("输入边(vi,vj)的顶点序号:\n");
              scanf("%d,%d", &i, &j);                   //输入边(vi,vj)的顶点序号
              e = (EdgeNode *)malloc(sizeof(EdgeNode)); //生成边表结点
              e->adjvex = j;                            //邻接序号为j
              e->next = G->adjlist[i].firstedge;        //将e指针指向当前顶点指向的结点
              G->adjlist[i].firstedge = e;              //将当前顶点的指针指向e
      
              e = (EdgeNode *)malloc(sizeof(EdgeNode)); //生成边表结点
              e->adjvex = i;                            //邻接序号为i
              e->next = G->adjlist[j].firstedge;        //将e指针指向当前顶点指向的结点
              G->adjlist[j].firstedge = e;              //将当前顶点的指针指向e
          }
      }
      ```

#### 7.2.3.十字链表

- 十字链表（Orthogonal List）：将邻接表和逆邻接表整合在一起（多用于有向图）

  - 顶点表结构

    | data | firstin | firstout |
    | ---- | ------- | -------- |

    - data：数据域，存储定点信息
    - firstin：指针域，表示入边头指针，指向该顶点的入边表中第一个结点
    - firstout：指针域，表示出边头指针，指向该顶点的出边表中第一个结点

  - 边表结构

    | tailvex | headvex | headlink | taillink |
    | ------- | ------- | -------- | -------- |

    - tailvex：数据域，弧起点在顶点表的下标
    - headvex：数据域，弧终点在顶点表的下标
    - headlink：入边表指针域，指向终点相同的下一条边
    - taillink：出边表指针域，指向起点相同的下一条边

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-14ace418de53697a4d26d976e1debf3c-75-c5b1d0.png" alt="1" style="zoom: 80%;"/>

#### 7.2.4.邻接多重表

- 邻接多重表：简化对无向表边的操作

  - 顶点表结构

    | data | firstedge |
    | ---- | --------- |

    - data：数据域，存储定点信息
    - firstedge：指针域，指向边表第一个结点

  - 边表结构

    | ivex | ilink | jvex | jlink |
    | ---- | ----- | ---- | ----- |

    - ivex,jvex：数据域，与某条边依附的两个顶点在顶点表中的下标
    - ilink：指针域，指向依附顶点ivex的下一条边
    - jlink：指针域，指向依附顶点jvex的下一条边

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-7cab69ce0a8719c3221f6fa7eae3c47f-76-1d1a96.png" alt="1" style="zoom: 80%;"/>

#### 7.2.5.边集数组

- 边集数组：由两个一维数组组成，一个是存储顶点信息；另一个是存储边的信息（适用于边操作）

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-b057f4a6a7965888b205a58620972bfe-77-c24ab4.png" alt="1" style="zoom: 80%;"/>



### 7.3.图的遍历

#### 7.3.1.深度优先遍历

- 深度优先遍历（Depth_First_Search）：简称DFS

  - 递归过程

  - 从图中某个顶点vv出发，访问此顶点

  - 然后从vv的未被访问的邻接点出发深度优先遍历图，直至图中所有和vv有路径相通的顶点都被访问到

  - 图中尚有顶点未被访问，则另寻图中一个未曾被访问的顶点作起始点，重复上述步骤，直至图中所有顶点都被访问为止

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-2bb62f644aba648a3e6a5fd036fe8404-78-be414c.png" alt="1" style="zoom: 60%;"/>

  

- 邻接矩阵的深度优先遍历

  - ```c
    typedef int Boolean;
    Boolean visited[MAXVEX]; //访问标志的数组
    //邻接矩阵的深度优先递归算法
    void DFS_MG(MGraph G, int i)
    {
        int j;
        visited[i] = TRUE;
        printf("%c ", G.vexs[i]); //打印顶点，可改为其他操作
        for (j = 0; j < G.numVertexes; j++)
        {
            if (G.arc[i][j] == 1 && !visited[j])
            {
                DFS(G, j); //对未访问的邻接顶点递归调用
            }
        }
    }
     ```
    

  -  ```c
      //邻接矩阵的深度遍历操作
      void DFSTraverse_MG(MGraph G)
      {
          int i;
          for (i = 0; i < G.numVertexes; i++)
          {
              visited[i] = FALSE; //初始化所有顶点状态都是未访问过状态
          }
          for (i = 0; i < G.numVertexes; i++)
          {
              if (!visited[i])
              { //对未访问过的顶点调用DFS，若是连通图只会执行一次
                  DFS_MG(G, i);
              }
          }
      }
      ```

      - 时间复杂度：**O(n<sup>2</sup>)**

- 邻接表的深度优先遍历

  - ```c
    //邻接表的深度优先递归算法
    void DFS_ALG(GraphAdjList GL, int i)
    {
        EdgeNode *p;
        visited[i] = TRUE;
        printf("%c ", GL.adjlist[i].data); //打印顶点，可改为其他操作
        p = GL.adjlist[i].firstedge;
        while (p)
        {
            if (!visited[p->adjvex])
            {
                DFS(GL, p->adjvex); //对未访问的邻接顶点递归调用
            }
            p=p->next;
        }
    }
    ```
    
    
    
  - ```c
    //邻接表深度优先遍历操作
    void DFSTraverse_ALG(GraphAdjList GL)
    {
        int i;
        for (int i = 0; i < GL.numVertexes; i++)
        {
            visited[i] = FALSE; //初始化所有顶点状态都是未访问过状态
        }
        for (i = 0; i < GL.numVertexes; i++)
        {
            if (!visited[i])
            { //对未访问过的顶点调用DFS，若是连通图只会执行一次
                DFS_ALG(GL, i);
            }
        }
    }
    ```
  
    - 时间复杂度：**O(n+e)**

#### 7.3.2.广度优先遍历

- 广度优先遍历（Breadth_First_Search）：简称BFS
  - 层序遍历

  - 将图变形：选取顶点`v`为第一层，`v`的邻接点作为第二层，依次类推

  - 扫描第一个结点（即第一层），将其入队

  - 遍历队的头结点的邻接点，头结点标记后出队，将头结点的邻接点全部入队

  - 循环上一步，直至所有顶点扫描完成，再将栈中剩余结点标记后出栈

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-05c6e379fe3a0a250da845f3095158c2-79-8c6413.png" alt="1" style="zoom: 60%;"/>

    

- 邻接矩阵的广度优先遍历

  - ```c
    //邻接矩阵的广度优先遍历算法
    void BFSTraverse_MG(MGraph G)
    {
        int i, j;
        Queue Q;
        for (i = 0; i < G.numVertexes; i++)
        {
            visited[i] = FALSE;
        }
        InitQueue(&Q); //初始化一辅助队列
        for (i = 0; i < G.numVertexes; i++)
        { //对每一个顶点做循环
            if (!visited[i])
            {                             //若是未访问就处理
                visited[i] = TRUE;        //设置当前顶点访问过
                printf("%c ", G.vexs[i]); //打印顶点，可改为其他操作
                EnQueue(&Q, i);           //将此顶点入队
                while (!QueueEmpty(Q))
                {
                    DeQueue(&Q, &i); //将队中元素出队，赋值给i
                    for (j = 0; j < G.numVertexes; j++)
                    {
                        //判断其他顶点若与当前顶点存在边且未被访问过
                        if (G.arc[i][j] == 1 && !visited[j])
                        {
                            visited[j] = TRUE;        //设置此顶点访问过
                            printf("%c ", G.vexs[j]); //打印顶点，可改为其他操作
                            EnQueue(&Q, j);           //将找到的此顶点入队
                        }
                    }
                }
            }
        }
    }
    ```

    - 时间复杂度：**O(n<sup>2</sup>)**

    

- 邻接表的广度优先遍历

  - ```c
    //邻接表的广度优先遍历算法
    void BFSTraverse_ALG(GraphAdjList GL)
    {
        int i;
        EdgeNode *p;
        Queue Q;
        for (i = 0; i < GL.numVertexes; i++)
        {
            visited[i] = FALSE;
        }
        InitQueue(&Q); //初始化一辅助队列
        for (i = 0; i < GL.numVertexes; i++)
        { //对每一个顶点做循环
            if (!visited[i])
            {                                      //若是未访问就处理
                visited[i] = TRUE;                 //设置当前顶点访问过
                printf("%c ", GL.adjlist[i].data); //打印顶点，可改为其他操作
                EnQueue(&Q, i);                    //将此顶点入队
                while (!QueueEmpty(Q))
                {
                    DeQueue(&Q, &i);             //将队中元素出队，赋值给i
                    p = GL.adjlist[i].firstedge; //找到当前顶点边表头指针
                    while (p)
                    {
                        //若当前顶点未被访问
                        if (!visited[p->adjvex])
                        {
                            visited[p->adjvex] = TRUE;                 //设置此顶点访问过
                            printf("%c ", GL.adjlist[p->adjvex].data); //打印顶点
                            EnQueue(&Q, p->adjvex);                    //将找到的顶点入队
                        }
                        p = p->next; //指针指向下一个邻接点
                    }
                }
            }
        }
    }
    ```

    - 时间复杂度：**O(n+e)**




### 7.4.最小生成树

#### 7.4.1.最小生成树的定义

- 连通图的生成树：极小连通子图，含有图中所有顶点，但只有足以构成一棵树的`n-1`条边
- 最小生成树：把构成连通网的最小代价生成树称为最小生成树（Minimum Cost Spanning Tree）
- Prim算法多由于边稠密图，Kruscal算法多用于边稀疏图



#### 7.4.2.普里姆（Prim）算法

- 算法思路：从某一顶点开始， 每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止

<img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-8bc4ad3a521abf36f15e8f3b2c5efc6f-80-a95488.png" alt="1" style="zoom: 40%;"/>

- Prim算法生成最小生成树

  - ```c
    // Prim算法生成最小生成树
    void MiniSpanTree_Prim(MGraph G)
    {
        int min, i, j, k;
        int adjvex[MAXVEX];  //保存相关顶点下标
        int lowcost[MAXVEX]; //保存相关顶点边的权值，=0表示此顶点已加入生成树
        lowcost[0] = 0;      //初始化第一个权值为0，即v0加入生成树
        adjvex[0] = 0;       //初始化第一个顶点下标为0
        for (i = 1; i < G.numVertexes; i++)
        {
            lowcost[i] = G.arc[0][i]; //将v0顶点与之有边的权值存入数组
            adjvex[i] = 0;            //初始化都为v0的下标
        }
        for (i = 1; i < G.numVertexes; i++)
        {
            min = INFINITY; //初始化最小权值为无穷，通常设置为不可能的数字
            j = 1;k = 0;
            while (j < G.numVertexes)
            { //循环全部顶点
                if (lowcost[j] != 0 && lowcost[j] < min)
                {                     //如果权值部位0且权值小于min
                    min = lowcost[j]; //则让当前权值成为最小值
                    k = j;            //将当前最小值小标存入k
                }
                j++;
            }
            printf("(%d,%d)", adjvex[k], k); //打印当前顶点边中权值最小边
            lowcost[k] = 0;                  //将当前顶点的权值置0，此顶点完成任务
            for (j = 1; j < G.numVertexes; j++)
            {
                if (lowcost[j] != 0 && G.arc[k][j] < lowcost[j])
                {//若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值
                    lowcost[j] = G.arc[k][j]; //将较小权值存入lowcost
                    adjvex[j] = k;            //将下标为k的顶点存入adjvex
                }
            }
        }
    }
    ```
    
    - 时间复杂度：**O(n<sup>2</sup>)**
    
  - 算法实现
  
    - 从$v_0$开始（`adjvex[0] = 0;`），$v_0$加入生成树（`lowcost[0] = 0;`）
    - 扫描邻接矩阵，将与$v_0$邻接的顶点边的权值纳入`lowcost`数组，并将`adjvex`数组的值全设为0
    - 从`lowcost`数组找出最小权值，将新顶点$v_k$加入生成树（`lowcost[k]=0`）
    - 扫描邻接矩阵，将与新顶点$v_k$邻接的顶点边的权值纳入`lowcost`数组，并将这些顶点的`adjvex`值改为$k$
    - 重复上两步，直至所有顶点加入生成树

#### 7.4.3.克鲁斯卡尔（Kruskal）算法

- 算法思路：每次选择一条权值最小的边，使这条边的两头连通（原本已经连通的不选），即该两点纳入生成树，直到所有顶点连通

- 边集数组

  - ```c
    //对边集数组Edge结构的定义
    typedef struct
    {
        int begin;
        int end;
        int weight;
    } Edge;
    ```

- 边集数组排序

  - ```c
    //交换边集数组的项
    void Swapn(Edge *edges, int i, int j)
    {
        int temp;
        temp = edges[i].begin;
        edges[i].begin = edges[j].begin;
        edges[j].begin = temp;
        temp = edges[i].end;
        edges[i].end = edges[j].end;
        edges[j].end = temp;
        temp = edges[i].weight;
        edges[i].weight = edges[j].weight;
        edges[j].weight = temp;
    }
    //对权值进行排序
    void Sort(Edge edges[], MGraph *G)
    {
        int i, j;
        for (i = 0; i < G->numEdges; i++)
        {
            for (j = i + 1; j < G->numEdges; j++)
            {
                if (edges[i].weight > edges[j].weight)
                {
                    Swapn(edges, i, j);
                }
            }
        }
    }
    ```

<img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-5b082dc2c5ff300f4b1e9a41a6a44542-81-051d63.png" alt="1" style="zoom: 40%;"/>

- Kruskal算法生成最小生成树

  - ```c
    // Kruscal算法生成最小生成树
    void MiniSpanTree_Kruscal(MGraph G)
    {
        int i, j, k, n, m;
        Edge edges[MAXVEX]; //定义边集数组
        int parent[MAXVEX]; //定义一数组用来判断边是否形成回路
        k=0;
        for (i = 0; i < G.numVertexes - 1; i++)
        {//构建边集数组
            for (j = i + 1; j < G.numVertexes; j++)
            {
                if (G.arc[i][j] < INFINITY)
                {
                    edges[k].begin = i;edges[k].end = j;
                    edges[k].weight = G.arc[i][j];
                    k++;
                }
            }
        }
        Sort(edges, &G); //边集数组排序
        for (i = 0; i < G.numVertexes; i++)
        {
            parent[i] = 0; //初始化数组值为0
        }
        for (i = 0; i < G.numEdges; i++)
        { //循环每一条边
            n = Find(parent, edges[i].begin);
            m = Find(parent, edges[i].end);
            if (n != m)
            {                  //假如n与m不等，说明此边没有与现有生成树形成回路
                parent[n] = m; //将此边的结尾顶点放入下标为起点的parent中
                               //表示此顶点已经在生成树集合中
                printf("(%d,%d) %d", edges[i].begin, edges[i].end, edges[i].weight);
            }
        }
    }
    ```
    
  - ```c
    //查找连线顶点的尾部下标
    int Find(int *parent, int f)
    {
        while (parent[f] > 0)
        {
            f = parent[f];
        }
        return f;
    }
    ```
  
    - 时间复杂度：**O(eloge)**
  
  - 算法实现
  
    - 构建边集数组并从小到大排序
    - 初始化`parent`数组全为0
    - 循环每一条边，判断其是否已纳入生成树，直至所有顶点纳入生成树
  
  - `parent`数组：假设`parent={1,5,8,7,7,8,0,0,6}`
  
    - `parent`构成了连通的边集和（1个或多个）
    - `parent[0]=1，parent[1]=5,parent[5]=8,parent[8]=6,parent[6]=0`，`parent[2]=8`，$\{v_0,v_1,v_2,v_5,v_6,v_8\}$构成了集合$A$，此集合中顶点是联通的
    - `parent[3]=7,parent[7]=0`，`parent[4]=7`，$\{v_3,v_4,v_7\}$构成了集合$B$，此集合中顶点是联通的
  



### 7.5.最短路径

#### 7.5.1.迪杰斯特拉（Dijkstra）算法

- 算法思路：从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止
  - 贪心算法（贪婪算法）：在对问题求解时，总是做出在当前看来是最好的选择
    - 建立数学模型来描述问题
    - 把求解的问题分成若干个子问题
    - 对每个子问题求解，得到子问题的局部最优解
    - 把子问题的解局部最优解合成原来解问题的一个解

<img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-55cdefe5bc8e24a8f9d7f90f7f1ddf98-82-886178.png" alt="1" style="zoom: 40%;"/>



- Dijkstra求最短路径

  - ```c
    typedef int Patharc[MAXVEX];        //用于存储最短路径下标的数组
    typedef int ShortPathTable_D[MAXVEX]; //用于存储到个顶点最短路径的权值和
    // Dijkstra算法，求最短路径P[v]及带权长度D[v]
    // P[v]的值为前驱顶点下标，D[v]表示v0到v的最短路径长度和
    void ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable_D *D)
    {
        int v, w, k, min;
        int final[MAXVEX]; // final[w]=1表示求得顶点v0至vw的最短路径
        for (v = 0; v < G.numVertexes; v++)
        {
            final[v] = 0;           //全部顶点初始化为未知最短路径状态
            (*D)[v] = G.arc[v0][v]; //将于v0点有连线的顶点加上权值
            (*P)[v] = 0;            //初始化路径数组P为0
        }
        (*D)[v0] = 0;  // v0至v0路径为0
        final[v0] = 1; // v0至v0不需求路径
        //开始主循环，每次求得v0到某个v顶点的最短路径
        for (v = 1; v < G.numVertexes; v++)
        {
            min = INFINITY; //当前所知离v0顶点的最近距离
            for (w = 0; w < G.numVertexes; w++)
            { //寻找离v0最近的顶点
                if (!final[w] && (*D)[w] < min)
                {
                    k = w;
                    min = (*D)[w]; // w顶点离v0顶点更近
                }
            }
            final[k] = 1; //将目前找的的最近顶点置为1
            for (w = 0; w < G.numVertexes; w++)
            { //修正当前最短路径及距离
                //如果经过v顶点的路径比现在这条路径的长度短的话
                if (!final[w] && (min + G.arc[k][w] < (*D)[w]))
                {                                //说明找到了更短的路径，修正D[w]和P[w]
                    (*D)[w] = min + G.arc[k][w]; //修改当前路径长度
                    (*P)[w] = k;
                }
            }
        }
    }
    ```

    - 时间复杂度：**O(n<sup>2</sup>)**-源点到终点，**O(n<sup>3</sup>)**-所有源点到终点

  - 算法实现

    - `final`数组判断$v_0$至$v_w$路径是否找到（=1即已找到）；`P`数组存路径，`D`数组存到各个顶点的路径长度
    - 初始化：`final`数组均为0，`P`数组均为0，`D`数组为$v_0$至各顶点路径长度（未连通为`INFINITY`）；`D[v0]=0,final[v0]=1`，$v_0$到$v_0$不用求路径
    - 找最近顶点：找距$v_0$最近的顶点$v_w$且`final[w]!=1`，令`min=D[w],final[w]=1`
    - 修正`D`数组：若经过$v_w$顶点的路径比现在这条路径的长度短的话，修正`D`数组，并在`P`数组中添加路径
    - 重复上两步，直至所有顶点都找到最短路径

#### 7.5.2.弗洛伊德（Floyd）算法

- 算法思路：使用动态规划思想，将问题求解分为多个阶段

  - 初始：不允许其他顶点中转，求最短路径
  - #0：允许在$v_0$中转，求最短路径
  - #1：允许在$v_0,v_1$中转，求最短路径
  - #2：允许在$v_0,v_1,v_2$中转，求最短路径
  - $\dots$
  - #n-1：允许在$v_0,v_1,\dots,v_n-1$中转，求最短路径

- 示例

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-6f9525c88020d9655d1993e47e32af8f-83-4b7b1d.png" alt="1" style="zoom: 40%;"/>

  - $D^{-1}[1][2],D^{-1}[2][1]$改为3
  - $P^{-1}[1][2],P^{-1}[2][1]$修改为当前中转顶点$v_0$顶点下标0
  - $D^0[v][w]=min\{D^{-1}[v][w],D^{-1}[v][0]+D^{-1}[0][w]\}$

<img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-07ae73c0c5d78da59b09f900fc3032bc-84-e9dbce.png" alt="1" style="zoom: 40%;"/>



- Floyd求最短路径

  - ```c
    typedef int Pathmatrix[MAXVEX][MAXVEX];
    typedef int ShortPathTable_F[MAXVEX][MAXVEX];
    // Floyd算法，求各顶点v到其余顶点w最短路径P[v][w]及带权长度D[v][w]
    void ShortestPath_Floyd(MGraph G, Pathmatrix *P, ShortPathTable_F *D)
    {
        int v, w, k;
        for (v = 0; v < G.numVertexes; v++)
        { //初始化D与P
            for (w = 0; w < G.numVertexes; w++)
            {
                (*D)[v][w] = G.arc[v][w]; // D[v][w]值即为对应点间的权值
                (*P)[v][w] = w;           //初始化P
            }
        }
        for (k = 0; k < G.numVertexes; k++)
        {
            for (v = 0; v < G.numVertexes; v++)
            {
                for (w = 0; w < G.numVertexes; w++)
                {
                    if ((*D)[v][w] > (*D)[v][k] + (*D)[k][w])
                    {   //如果经过下标为k顶点路径比原两点间路径更短
                        //将当前顶点权值改为更小的一个
                        (*D)[v][w] = (*D)[v][k] + (*D)[k][w];
                        (*P)[v][w] = (*P)[v][k]; //路径设置经过下标为k的顶点
                    }
                }
            }
        }
    }
    ```

    - 时间复杂度：**O(n<sup>3</sup>)**
  
  - 算法实现
  
    - `P`数组存路径，`D`数组存到各个顶点的路径长度
  
    - $D^0[v][w]=min\{D^{-1}[v][w],D^{-1}[v][0]+D^{-1}[0][w]\}$，所有顶点经过$v_0$中转，计算最短路径是否变化
  
    - $D^1$以$D^0$为基础，$D^2$以$D^1$为基础，$\dots$，$D^n$以$D^{n-1}$为基础，修改$D$数组和$P$数组
  
      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-b51cc57759b8e26da5d2e22f725d5598-85-813f13.png" alt="1" style="zoom: 40%;"/>
  
    
  
  - 通过$P$数组求路径
  
    - $P[v][w]$，`v`代表源点，`w`代表终点
  
    - 每次修改源点值，其值等于上一个数组值$P[v^0][w]=v^1,P[v^1][w]=v^2,\dots,p[v^n][w]=w$
  
    - ```c
      //打印最短路径
      for (v = 0; v < G.numVertexes; v++)
      {
          for (w = v + 1; w < G.numVertexes; w++)
          {
              printf("v%d-v%d weight: %d ", v, w, D[v][w]);
              k = P[v][w];           //获得第一个路径顶点下标
              printf("path: %d", v); //打印源点
              while (k != w)
              {                        //如果路径顶点下标不是终点
                  printf(" -> %d", k); //打印路径顶点
                  k = P[k][w];         //获得下一个路径顶点下标
              }
              printf(" -> %d\n", w); //打印终点
          }
          printf("\n");
      }
      ```
  
      

### 7.6.拓扑排序

#### 7.6.1.拓扑排序的定义

- AOV网：在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表是活动的网，成为AOV网（Activity On Vertex）
- 拓扑序列：设$G=\{V,E\}$是一个具有n个顶点的有向图，$V$中的顶点序列$v_1,v_2,\dots,v_n$，满足顶点$v_i$到$v_j$有一条路径，则在顶点序列中顶点$v_i$必须在帝国点$v_j$之前；我们称这样的顶点序列为一个拓扑序列（AOV网的拓扑序列不止一条）
- 拓扑排序：对一个有向图构造拓扑序列的过程（构造过程中，所有顶点都被输出，不产生回路，可构成AOV网，否则无法构成AOV网）

#### 7.6.2.拓扑排序算法

- 算法思路：从AOV网中选择一个入度为0的顶点输出，然后山区此顶点，并删除以此顶点为尾的弧，继续重复此操作，直到输出全部顶点或AOV网中不存在入度尾0的顶点为止

  - 顶点表

    | in   | data | firstedge |
    | ---- | ---- | --------- |

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-24e71445c5d653e66aa96337d1386958-86-9cc19d.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-b5833e06466f8464c088dea1b09d1a50-87-82330c.png" alt="1" style="zoom: 40%;"/>

- 邻接表存储结构定义代码描述

  - ```c
    //边表结点
    typedef struct EdgeNode
    {
        int adjvex;            //邻接点域，存储该顶点对应的下标
        EdgeType weight;       //用于存储权值
        struct EdgeNode *next; //链域，指向下一个邻接点
    } EdgeNode;
    //顶点表结点
    typedef struct VertexNode
    {
        int in;              //顶点入度
        VertexType data;     //顶点域，存储顶点信息
        EdgeNode *firstedge; //边表头指针
    } VertexNode, AdjList[MAXVEX];
    //邻接表
    typedef struct
    {
        AdjList adjlist;
        int numVertexes, numEdges; //图中当前顶点数和边数
    } graphAdjList, *GraphAdjList;
    ```

  

- 拓扑排序

  - ```c
    //拓扑排序，若GL无回路，则输出拓扑排序序列
    Status TopologicalSort(GraphAdjList GL)
    {
        EdgeNode *e;
        int i, k, gettop;
        int top = 0;   //用于栈指针下标
        int count = 0; //用于统计输出的顶点个数
        int *stack;    //建栈存储入度为0的顶点
        stack = (int *)malloc(GL->numVertexes * sizeof(int));
        for (i = 0; i < GL->numVertexes; i++)
        {
            if (GL->adjlist[i].in == 0)
            {
                stack[++top] = i; //将入度为0的顶点入栈
            }
        }
        while (top != 0)
        {
            gettop = stack[top--];                      //出栈
            printf("%c -> ", GL->adjlist[gettop].data); //打印此顶点
            count++;                                    //统计输出顶点数
            for (e = GL->adjlist[gettop].firstedge; e; e = e->next)
            { //对此顶点弧表遍历
                k = e->adjvex;
                if (!(--GL->adjlist[k].in))
                {                     //将k号顶点邻接点的入度减1
                    stack[++top] = k; //若为0则入栈，以便于下次循环输出
                }
            }
        }
        if (count < GL->numVertexes)
        { //如果count小于顶点数，说明存在回路
            return ERROR;
        }
        else
        {
            return OK;
        }
    }
    ```

    - 时间复杂度：**O(n+e)**

  - 算法实现

    - 把入度为0的顶点入栈
    - 栈顶出栈，打印此顶点
    - 遍历其弧表，将弧表上顶点的入度-1，若此时有顶点入度为0，入栈
    - 重复上两步，直至所有顶点入度为0



### 7.7.关键路径

#### 7.7.1.关键路径的定义

- AOE网：在一个表示工程的有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动持续的时间，这种有向图的边表示活动的网称为AOE网（Activity On Edge Network）

  - 没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-4629fe5f4b390816e6b21d7fb235c6f5-88-dd103b.png" alt="1" style="zoom: 36%;"/>

  - AOE网与AOV网

    - AOV网是用顶点表示活动的网，只描述活动之间的制约关系
    - AOE网是用边表示活动的网，边上的权值表示活动持续的时间
    - AOE网是要建立在活动之间制约关系没有矛盾的基础上，再来分析工程

- 关键路径：路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动

#### 7.7.2.关键路径算法

- 关键路径算法原理：若活动的最早开工时间等于最晚开工时间，该活动即为关键路径

  - 事件的最早发生时间etv（earliest time of vertex）：即顶点$v_k$的最早发生时间
  - 事件的最晚发生时间ltv（latest time of vertex）：即顶点$v_k$的最晚发生时间，即超出此时间工作就会延误
  - 活动的最早开工时间ete（earliest time of edge）：即弧$a_k$的最早发生时间
  - 活动的最晚开工时间lte（latest time of edge）：即弧$a_k$的最晚发生时间，即不推迟工期的最晚开工时间
  - 通过$etv$和$ltv$可以求得$ete$和$lte$，再根据$ete[k]$和$lte[k]$是否相等来判断$a_k$是否为关键活动

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-4298ec169a1fc61bf57ead4d9e6eea14-89-04f35c.png" alt="1" style="zoom: 36%;"/>

  

- 拓扑排序求etv

  - ```c
    int *etv, *ltv; //事件最早发生时间和最迟发生时间数组
    int *stack2;    //用于存储拓扑序列的栈
    int top2;       //用于stack2的指针
    //拓扑排序，若GL无回路，则输出拓扑排序序列
    Status TopologicalSort(GraphAdjList GL)
    {
        EdgeNode *e;
        int i, k, gettop;
        int top1 = 0;  //用于栈指针下标
        int count = 0; //用于统计输出的顶点个数
        int *stack1;   //建栈存储入度为0的顶点
        stack1 = (int *)malloc(GL->numVertexes * sizeof(int));
        for (i = 0; i < GL->numVertexes; i++)
        {
            if (GL->adjlist[i].in = 0)
            {
                stack1[++top1] = i; //将入度为0的顶点入栈
            }
        }
        top2 = 0;                                           //初始化为0
        etv = (int *)malloc(GL->numVertexes * sizeof(int)); //事件最早发生时间
        for (i = 0; i < GL->numVertexes; i++)
        {
            etv[i] = 0; //初始化为0
        }
        stack2 = (int *)malloc(GL->numVertexes * sizeof(int)); //初始化
        while (top1 != 0)
        {
            gettop = stack1[top1--];                    //出栈
            count++;                                    //统计输出顶点数
            stack2[++top2] = gettop;                    //将弹出的顶点序号压入拓扑序列的栈
            for (e = GL->adjlist[gettop].firstedge; e; e = e->next)
            { //对此顶点弧表遍历
                k = e->adjvex;
                if (!(--GL->adjlist[k].in))
                {                       //将k号顶点邻接点的入度减1
                    stack1[++top1] = k; //若为0则入栈，以便于下次循环输出
                }
                if ((etv[gettop] + e->weight) > etv[k])
                { //求各顶点事件最早发生时间值
                    etv[k] = etv[gettop] + e->weight;
                }
            }
        }
        if (count < GL->numVertexes)
        { //如果count小于顶点数，说明存在回路
            return ERROR;
        }
        else
        {
            return OK;
        }
    }
    ```

  - $etv[k]=\begin{cases}0,&当k=0时\\max\{etv[i]+len<v_i,v_k>\},&当k\neq0且<v_i,v_k>\in P[k]时\end{cases}$

    - $P[k]$表示所有到达顶点$v_k$的弧的集合，$len<v_i,v_k>$是弧$<v_i,v_k>$上的权值

- 求关键路径

  - ```c
    //求关键路径，GL为有向网，输出GL的各项关键活动
    void CriticalPath(GraphAdjList GL)
    {
        EdgeNode *e;
        int i, gettop, k, j;
        int ete, lte;       //声明活动最早发生时间和最迟发生时间变量
        TopologicalSort(GL);//求拓扑序列，计算数组etv和stack2的值
        ltv = (int *)malloc(GL->numVertexes * sizeof(int)); //事件最晚发生时间
        for (i = 0; i < GL->numVertexes; i++)
        {
            ltv[i] = etv[GL->numVertexes - 1]; //初始化ltv
        }
        while (top2 != 0)
        {                            //计算ltv
            gettop = stack2[top2--]; //将拓扑序列出栈，后进先出
            for (e = GL->adjlist[gettop].firstedge; e; e = e->next)
            { //求各顶点事件的最迟发生时间ltv值
                k = e->adjvex;
                if (ltv[k] - e->weight < ltv[gettop])
                { //求个顶点时间最晚发生时间
                    ltv[gettop] = ltv[k] - e->weight;
                }
            }
        }
        for (j = 0; j < GL->numVertexes; j++)
        { //求ete，lte和关键活动
            for (e = GL->adjlist[j].firstedge; e; e = e->next)
            {
                k = e->adjvex;
                ete = etv[j];             //活动最早发生时间
                lte = ltv[k] - e->weight; //活动最迟发生时间
                if (ete == lte)
                { //两者相等即在关键路径上
                    printf("<v%d,v%d> length: %d , ", 
                    GL->adjlist[j].data, GL->adjlist[k].data, e->weight);
                }
            }
        }
    }
    ```

    - 时间复杂度：**O(n+e)**

  - $ltv[k]=\begin{cases}etv[k],&当k=n-1时\\min\{ltv[j]-len<v_k,v_j>\},&当k<n-1且<v_k,v_j>\in S[k]时\end{cases}$

    - $S[k]$表示所有从顶点$v_k$出发的弧的集合，$len<v_k,v_j>$是弧$<v_k,v_j>$上的权值
  
- $ete<k,j>=etv[k]$
  
- $lte<k,j>=ltv[j]-len<v_k,v_j>$
  
- 若$ete<k,j>=lte<k,j>$，则$<k,j>$是关键活动；若$ete<k,j>\neq lte<k,j>$，则$<k,j>$不是关键活动

-----



## 8.查找

### 8.1.查找概论

- 查找表（Search Table）：由同一类型的数据元素（或记录）构成的集合

- 关键字（Key）：数据元素中某个数据项的值

  - 主关键字（Primary Key）：若此关键字可以唯一的标识一个记录，则此关键字为主关键字

  - 次关键字（Secondary Key）：对于某些可以识别多个数据元素（或记录）的关键字，称为次关键字

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-7c30513775419c8080e84ee30f205bc2-90-d3fa95.png" alt="1" style="zoom: 40%;"/>

- 查找（Searching）：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）

- 查找表分类

  - 静态查找表（Static Search Table）：只做查找操作的查找表
  - 动态查找表（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个元素



### 8.2.顺序表查找

- 顺序查找（Sequential Search）：又称线性查找；从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功；若直到最后一个（或第一个）记录，其关键字和给定值比较不等时，则查找失败

- 顺序表查找算法

  - ```c
    //顺序查找，a为数组，n为要查找的数组长度
    int Sequential_Search1(int *a, int n, int key)
    {
        int i;
        for (i = 0; i <= n; i++)
        {
            if (a[i] == key)
            {
                return i;
            }
        }
        return 0;
    }
    ```

  - 时间复杂度：**O(n)**

  

- 顺序表查找算法优化

  - ```c
    //有哨兵顺序查找
    int Sequential_Search2(int *a, int n, int key)
    {
        int i;
        a[0] = key; //设置a[0]为关键字值，称之为“哨兵”
        i = n;      //循环从组尾部开始
        while (a[i] != key)
        {
            i--;
        }
        return i; //返回0则说明查找失败
    }
    ```

    - 在`a[0]`设置哨兵，免去了每次去判断`i`是否越界
    - 时间复杂度：**O(n)**



### 8.3.有序表查找

#### 8.3.1.折半查找

- 折半查找（Binary Search）：又称二分查找

  - 前提：线性表中的记录须是关键码有序（通常从小到大）；线性表必须采用顺序存储

  - 基本思想：在有序表中，去中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找；重复上述步骤，直至查找成功或查找失败

  - ```c
    //折半查找
    int Binary_Search(int *a, int n, int key)
    {
        int low, high, mid;
        low = 1;  //定义最低下标为记录首位
        high = n; //定义最高下标为记录末位
        while (low <= high)
        {
            mid = (low + high) / 2; //折半
            if (key < a[mid])
            {                   //若查找值比中值小
                high = mid - 1; //最高下标调整到中值下标小一位
            }
            else if (key > a[mid])
            {                  //若查找值比中值大
                low = mid + 1; //最低下标调整到中值下标大一位
            }
            else
            {
                return mid; //若相等，则mid即为查找到的为止
            }
        }
        return 0;
    }
    ```

    - 时间复杂度：**O(logn)**

#### 8.3.2.插值查找

- 折半查找：$mid=\frac{1}{low+high}=low+\frac{1}{2}(high-low)$

- 改进：$mid=low+\frac{key-a[low]}{a[high]-a[low]}(high-low)$

- 插值查找（Interpolation Search）

  - 根据要查找的关键字$key$与查找表中最大最小记录的关键字比较后的查找方法，核心在于插值的计算公式$\frac{key-a[low]}{a[high]-a[low]}(high-low)$

  - ```c
    //插值查找
    int Interpolation_Search(int *a, int n, int key)
    {
        int low, high, mid;
        low = 1;  //定义最低下标为记录首位
        high = n; //定义最高下标为记录末位
        while (low <= high)
        {
            mid = low + ((key - a[low]) / (a[high] - a[low])) * (high - low); //插值
            if (key < a[mid])
            {                   //若查找值比中值小
                high = mid - 1; //最高下标调整到中值下标小一位
            }
            else if (key > a[mid])
            {                  //若查找值比中值大
                low = mid + 1; //最低下标调整到中值下标大一位
            }
            else
            {
                return mid; //若相等，则mid即为查找到的为止
            }
        }
        return 0;
    }
    ```

    - 时间复杂度：**O(logn)**

#### 8.3.3.斐波那契查找

- 斐波那契查找

  - 斐波那契查找算法核心思想

    - 当`key=a[mid]`，查找成功

    - 当`key<a[mid]`，新范围是第`low`个到第`mid-1`个，此时范围个数为`F[k-1]-1`个

    - 当`key>a[mid]`，新范围是第`mid+1`个到第`high`个，此时范围个数为`F[k-2]-1`个

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-6cb09c50f066640be912760ae96ff7d7-91-88b681.png" alt="1" style="zoom: 40%;"/>

    - $mid=low+F[k-1]-1$

  - 全局变量数组F：事先计算好的斐波那契数列

  - ```c
    //斐波那契查找
    int Fibonacci_Search(int *a, int n, int key)
    {
        int low, high, mid, i, k;
        low = 1;  //定义最低下标为记录首位
        high = n; //定义最高下标为记录末位
        k = 0;
        while (n > F[k] - 1)
        { //计算n位于斐波那契数列的位置
            k++;
        }
        for (i = n; i < F[k] - 1; i++)
        { //将不满的数值补全
            a[i] = a[n];
        }
        while (low <= high)
        {
            mid = low + F[k - 1] - 1; //计算当前分隔的下标
            if (key < a[mid])
            {                   //若查找记录小于当前分隔记录
                high = mid - 1; //最高下标调整到分割下标mid-1处
                k = k - 1;      //斐波那契数列下标减一位
            }
            else if (key > a[mid])
            {                  //若查找记录大于当前分隔记录
                low = mid + 1; //最低下标调整到分割下标mid+1处
                k = k - 2;     //斐波那契数列下标减两位
            }
            else
            {
                if (mid <= n)
                {
                    return mid; //若相等则说明mid即为查找到的位置
                }
                else
                {
                    return n; //若mid>n说明是补全数值，返回n
                }
            }
        }
        return 0;
    }
    ```

    - 时间复杂度：**O(logn)**

    

### 8.4.线性索引查找

#### 8.4.1.线性索引概述

- 索引：为了加快查找速度设计的一种数据结构；索引是把一个关键字与它对应的记录相关联的过程
  - 一个索引有若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息
  - 按结构分类：线性索引、树形索引和多级索引
- 线性索引技术
  - 线性索引就是将索引项集合组织为线性结构，也称索引表
  - 线性索引有稠密索引、分块索引和倒排索引等

#### 8.4.2.稠密索引

- 稠密索引：指在线性索引中，将数据集中的每个记录对应一个索引项；索引表中的索引项一定是按照关键码有序排列的

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-5c71e197021d0a0645ccf4beeddf21db-92-2828a4.png" alt="1" style="zoom: 35%;"/>

#### 8.4.3.分块索引

- 分块有序：把数据集的记录分成了若干块，且这些块需满足块内无序和块间有序（后一块所有记录的关键字均要大于前一块所有记录的关键字）

- 分块索引：对于分块有序的数据集，将每块对应一个索引表，这种索引方法叫分块索引

- 分块索引的索引项结构

  - 最大关键码：存储每一块中的最大关键字，保证下一块中的最小关键字比这一块大

  - 记录个数：存储了块中记录的个数，以便于循环时列用

  - 块首指针：用于指向块首数据元素的指针，便于对这一块中记录进行遍历

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-d4c9a46737d92efb137255617cffdba3-93-6ff6dc.png" alt="1" style="zoom: 35%;"/>

  

- 分块索引查找

  - 在分块索引中查找要查关键字所在的块（折半、插值等）
  - 根据块首指针找到对应的块，并在块中顺序查找关键码

- 分块索引平均查找长度

  - `n`个记录平均分成`m`块，每块`t`条记录，即`n=m*t`
  - $L_b$为查找索引表的平均查找长度；$L_w$为块中查找记录的平均查找长度；$ASL_w$为分块索引的平均查找长度
  - $L_b=\frac{m+1}{2},L_w=\frac{t+1}{2}$
  - $ASL_w=L_b+L_w=\frac{m+1}{2}+\frac{t+1}{2}=\frac{1}{2}(\frac{n}{t}+t)+1$
  - 最佳情况：$m=t,n=m*t=t^2;ASL_w=t+1=\sqrt{n}+1$


#### 8.4.4.倒排索引

- 示例

  - 文章

    - `1.Books and friends should be few but good`
    - `2.A good book is a good friend`

  - 单词表

    - | 英文单词 | 文章编号 |
      | -------- | -------- |
      | a        | 2        |
      | and      | 1        |
      | be       | 1        |
      | book     | 1,2      |
      | but      | 1        |
      | few      | 1        |
      | friend   | 1,2      |
      | good     | 1,2      |
      | is       | 2        |
      | should   | 1        |

- 倒排索引（Inverted Index）

  - 索引项结构：次关键码（`英文单词`），记录号表（`文章编号`）
  - 记录号表存储具有相同次关键字的所有记录的记录号（可以是只想记录的指针或是记录的主关键字）



### 8.5.二叉排序树

#### 8.5.1.二叉排序树概述

- 动态查找表是在查找时需插入或删除的查找表，设计数据结构既可以提高查找效率，也可以提高插入和删除效率
- 二叉排序树（Binary Sort Tree）：又称二叉查找树；可为空树
  - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
  - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
  - 左右子树也为二叉排序树

#### 8.5.2.二叉排序树查找操作

- 二叉树结构

  - ```c
    //二叉树的二叉链表结点结构定义
    typedef struct BiTNode
    {
        ElemType data;                   //结点数据
        struct BiTNode *lchild, *rchild; //左右孩子指针
    } BiTNode, *BiTree;
    ```

- 二叉排序树查找操作

  - ```c
    //递归查找二叉排序树T中是否存在key
    //指针f指向T的双亲，其初始调用值为NULL
    //若查找成功，则指针p指向该数据元素结点；否则指针p指向查找路径上访问的最后一个结点
    Status SearchBST(BiTree T, int key, BiTree f, BiTree *p)
    {
        if (!T)
        { //查找不成功
            *p = f;
            return FALSE;
        }
        else if (key == T->data)
        { //查找成功
            *p = T;
            return TRUE;
        }
        else if (key < T->data)
        { //在左子树继续查找
            return SearchBST(T->lchild, key, T, p);
        }
        else
        { //在右子树继续查找
            return SearchBST(T->rchild, key, T, p);
        }
    }
    ```



#### 8.5.3.二叉排序树的插入操作

- 二叉排序树的插入操作

  - ```c
    //当二叉排序树T中不存在关键字等于key的数据元素时，插入key
    Status InsertBST(BiTree *T, int key)
    {
        BiTree p, s;
        if (!SearchBST(*T, key, NULL, &p))
        { //查找不成功
            s = (BiTree)malloc(sizeof(BiTNode));
            s->data = key;
            s->lchild = s->rchild = NULL;
            if (!p)
            {
                *T = s; //插入s为新的根结点
            }
            else if (key < p->data)
            {
                p->lchild = s; //插入s为左孩子
            }
            else
            {
                p->rchild = s; //插入s为右孩子
            }
            return TRUE;
        }
        else
        {
            return FALSE; //树中已有关键字相同的结点，不插入
        }
    }
    ```

- 创建二叉排序树

  - ```c
    int i;
    int a[10] = {62, 88, 58, 47, 35, 73, 51, 99, 37, 93};
    BiTree T = NULL;
    for (i = 0; i < 10; i++)
    {
        InsertBST(&T, a[i]);
    }
    ```



#### 8.5.4.二叉排序树的删除操作

- 删除结点的三种情况

  - 叶子结点

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-85ceb0dd81a8334aef75d4e4cbda06f3-94-2260c6.png" alt="1" style="zoom: 40%;"/>

  - 仅有左子树或右子树的结点

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-c28d33fda3d828405946b582d7a2e75e-95-a64067.png" alt="1" style="zoom: 50%;"/>

    

  - 既有左子树又有右子树的结点

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-c0699f3d928b5b9d04e4d8945aae0093-96-c0e3af.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-8fc9f2feabbcbb01b9c67e387e505b58-97-cb024c.png" alt="1" style="zoom: 40%;"/>

- 二叉排序树的删除操作

  - ```c
    //若二叉排序树T中存在关键字等于key的数据元素，删除该数据元素结点
    Status DeleteBST(BiTree *T, int key)
    {
        if (!*T)
        { //不存在关键字等于key的元素
            return FALSE;
        }
        else
        {
            if (key == (*T)->data)
            { //找到关键字等于key的元素
                return Delete(T);
            }
            else if (key < (*T)->data)
            {
                return DeleteBST(&(*T)->lchild, key);
            }
            else
            {
                return DeleteBST(&(*T)->rchild, key);
            }
        }
    }
    ```
    
    - 找到待删除的结点，将其删除
    - 若没有找到，返回`FALSE`

  - ```c
    //从二叉树中删除结点p，并重接它的左或右子树
    Status Delete(BiTree *p)
    {
        BiTree q, s;
        if ((*p)->rchild == NULL)
        { //右子树空则只需重接它的左子树
            q = *p;
            *p = (*p)->lchild;
            free(q);
        }
        else if ((*p)->lchild == NULL)
        { //左子树空则只需重接它的右子树
            q = *p;
            *p = (*p)->rchild;
            free(q);
        }
        else
        { //左右子树均不空
            q = *p;
            s = (*p)->lchild;
            while (s->rchild)
            { //转左，然后向右到尽头（找待删结点的前驱）
                q = s;
                s = s->rchild;
            }
            (*p)->data = s->data; // s指向被删结点的直接前驱
            if (q != *p)
            {
                q->rchild = s->lchild; //重接q的右子树
            }
            else
            {
                q->lchild = s->lchild; //重接q的左子树
            }
            free(s);
        }
        return TRUE;
    }
    ```

    - 算法实现
      - 若待删结点的右子树为空，只需将待删结点的左孩子替换它自己，再释放待删结点
      - 若待删结点的左子树为空，只需将待删结点的右孩子替换它自己，再释放待删结点
      - 若待删结点的左右子树均不为空，找到待删结点的前驱或后继进行替换
        - 待删结点`p`，临时变量`q,s`，初始化：`q=p`
        - 转左（`s=p->lchild`），循环（`while(s->rchild)`）向右的尽头（`s=s->rchild`），找到待删结点的前驱结点，并使`q`始终是`s`的双亲结点（`q=s`）
        - 将待删结点的值替换为其前驱结点的值（`p->data = s->data`）
        - 若待删结点的左孩子的右子树为空，重接`q`的左子树（`q->lchild=s->lchild`），此时`q=p`
        - 若待删结点的左孩子的右子树不为空，重接`q`的右子树（`q->rchild=s->lchild`），此时`q!=p,q->rchild=s`
        - 释放前驱结点`s`（`free(s)`）



### 8.6.平衡二叉树（AVL）

#### 8.6.1.平衡二叉树概述

- 平衡二叉树（Self-Balancing Binary Search Tree/Height-Balanced Binary Tree）：也称AVL树

  - 二叉排序树

  - 每一个结点的左子树和右子树高度差的绝对值至多等于1

  - 平衡因子BF（Balance Factor）：将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子；值域`{-1，0，1}`

  - 最小不平衡子树：距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-092851500b6ad0c28360dd7e90479ec9-98-2a2675.png" alt="1" style="zoom: 40%;"/>

- 平衡二叉树实现原理

  - `a[10]={3,2,1,4,5,6,7,10,9,8}`

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-05beaf9183bbc53bf740533ea5600ed9-99-17844c.png" alt="1" style="zoom: 35%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-b027fee7cc1f4c386c24a5aca20740de-100-1e91fb.png" alt="1" style="zoom: 35%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-5024e7317a09865f519db1017c814f75-101-2e0925.png" alt="1" style="zoom: 35%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-a8f5ba0ea3c0d4acdac18bf1b580c0cb-102-809ee7.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-0d6de0544cbbc4b42b3c44be49ef791e-103-10ce01.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-aa0e4b768e5a1b16992100a467673b37-104-d0f33a.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-1052c48fbaec97e2aa7af32066125913-105-3f2eb5.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-97500989b16fbec78ceff4e9d308f1c8-106-140ea8.png" alt="1" style="zoom: 40%;"/>

  - 最小不平衡子树根结点`BF=2`，且根结点的孩子结点`BF`为正，整体右旋

  - 最小不平衡子树根结点`BF=-2`，且根结点的孩子结点`BF`为负，整体左旋

  - 最小不平衡子树根结点`BF=2`，且根结点的孩子结点`BF`为负，先子树左旋，再整体右旋

  - 最小不平衡子树根结点`BF=-2`，且根结点的孩子结点`BF`为正，先子树右旋，再整体左旋

#### 8.6.2.平衡二叉树实现算法

- 二叉树结构

  - ```c
    //二叉树的二叉链表结点结构定义
    typedef struct BiTNode
    {
        ElemType data;                   //结点数据
        int bf;                          //结点的平衡因子
        struct BiTNode *lchild, *rchild; //左右孩子指针
    } BiTNode, *BiTree;
    ```

- 右旋操作

  - ```c
    //对以P为根的二叉排序树作右旋处理
    void R_Rotate(BiTree *P)
    {
        BiTree L;
        L = (*P)->lchild;         // L指向P的左子树根结点
        (*P)->lchild = L->rchild; // L的右子树挂接为P的左子树
        L->rchild = (*P);         // P挂接为L的右子树
        *P = L;                   // P指向新的根结点
    }
    ```

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-6bcf6e5d2fad93b7c102175b36742f19-107-5e7974.png" alt="1" style="zoom: 50%;"/>

- 左旋操作

  - ```c
    //对以P为根的二叉排序树作左旋处理
    void L_Rotate(BiTree *P)
    {
        BiTree R;
        R = (*P)->rchild;         // R指向P的右子树根结点
        (*P)->rchild = R->lchild; // R的左子树挂接为P的右子树
        R->lchild = (*P);         // P挂接为R的左子树
        *P = R;                   // P指向新的根结点
    }
    ```

  

- 左平衡旋转

  - 传入需要调整平衡性的子树`T`，且`T`的根结点`BF`大于1

  - ```c
    #define LH 1  //左高
    #define EH 0  //等高
    #define RH -1 //右高
    //对以指针T所指结点为根的二叉树作左平衡处理
    void LeftBalance(BiTree *T)
    {
        BiTree L, Lr;
        L = (*T)->lchild; // L指向T的左子树根结点
        switch (L->bf)
        {        //检查T的左子树的平衡度，并作相应的平衡处理
        case LH: //新结点插入在T的左孩子的左子树上，要作单右旋处理
            (*T)->bf = L->bf = EH;
            R_Rotate(T);
            break;
        case RH:            //新结点插入在T的左孩子的右子树上，要作双旋处理
            Lr = L->rchild; // Lr指向T的左孩子的右子树根上
            switch (Lr->bf)
            { //修改T及其左孩子的平衡因子
            case LH:
                (*T)->bf = RH;
                L->bf = EH;
                break;
            case EH:
                (*T)->bf = L->bf = EH;
                break;
            case RH:
                (*T)->bf = EH;
                L->bf = LH;
                break;
            }
            Lr->bf = EH;
            L_Rotate(&(*T)->lchild); //对T的左子树作左旋平衡处理
            R_Rotate(T);             //对T作右旋平衡处理
            break;
        }
    }
    ```

  - 算法实现

    - `L=T->lchild`

    - `L->bf=1`，即根结点与左孩子`BF`同号，将`T,L`的`BF`都改为0，并对`T`进行右旋操作

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-6bcf6e5d2fad93b7c102175b36742f19-107-5e7974.png" alt="1" style="zoom: 50%;"/>

      

    - `L->bf=-1`，即根结点与左孩子`BF`异号，进行双旋处理，`Lr = L->rchild`

      - `Lr->bf=1`，修改`T,L`的`BF`，`T->bf=-1,L->bf=0`
      - `Lr->bf=0`，修改`T,L`的`BF`，`T->bf=0,L->bf=0`
      - `Lr->bf=-1`，修改`T,L`的`BF`，`T->bf=0,L->bf=1`
      - 双旋处理
        - `Lr->bf=0`
        - 对`T`的左孩子作左旋处理
        - 对`T`作右旋处理

        <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-b9b698d966cca9f8ef02279b763a0e56-108-84f115.png" alt="1" style="zoom: 70%;"/>

  

- 右平衡旋转

  - ```c
    //对以指针T所指结点为根的二叉树作右平衡处理
    void RightBalance(BiTree *T)
    {
        BiTree R, Rl;
        R = (*T)->rchild; // R指向T的右子树根结点
        switch (R->bf)
        {        //检查T的右子树的平衡度，并作相应平衡处理
        case RH: //新结点插入在T的右孩子的右子树上，要作单左旋处理
            (*T)->bf = R->bf = EH;
            L_Rotate(T);
            break;
        case LH:            //新结点插入在T的右孩子的左子树上，要作双旋处理
            Rl = R->lchild; // Rl指向T的右孩子的左子树根上
            switch (Rl->bf)
            { //修改T及其右孩子的平衡因子
            case RH:
                (*T)->bf = LH;
                R->bf = EH;
                break;
            case EH:
                (*T)->bf = R->bf = EH;
                break;
            case LH:
                (*T)->bf = EH;
                R->bf = RH;
                break;
            }
            Rl->bf = EH;
            R_Rotate(&(*T)->rchild); //对T的右子树作右旋平衡处理
            L_Rotate(T);             //对T作左旋平衡处理
        }
    }
    ```

  

- 二叉平衡树的插入操作

  - ```c
    //若在平衡二叉树T中不存在和e有相同关键字的结点，则插入结点;taller反映T长高与否
    Status InsertAVL(BiTree *T, int e, Status *taller)
    {
        if (!*T)
        { //插入新结点，树“长高”，置taller为TRUE
            *T = (BiTree)malloc(sizeof(BiTNode));
            (*T)->data = e;(*T)->bf = EH;
            (*T)->lchild = (*T)->rchild = NULL;
            *taller = TRUE;
        }
        else
        {
            if (e == (*T)->data)
            { //树中已存在和e有相同关键字的结点，则不插入
                *taller = FALSE;
                return FALSE;
            }
            if (e < (*T)->data)
            { //继续在T的左子树中进行搜索
                if (!InsertAVL(&(*T)->lchild, e, taller))
                    return FALSE;//未插入
                if (*taller)
                { //已插入到T的左子树且左子树“长高”
                    switch ((*T)->bf)
                    {        //检查T的平衡度
                    case LH: //原本左子树比右子树高，左平衡处理
                        LeftBalance(T);*taller = FALSE;break;
                    case EH: //原本左子树与右子树等高，现因左子树增高而增高
                        (*T)->bf = LH;*taller = TRUE;break;
                    case RH: //原本右子树比左子树高，现左右子树等高
                        (*T)->bf = EH;*taller = FALSE;break;
                    }
                }
            }
            else
            { //继续在T的右子树进行搜索
                if (!InsertAVL(&(*T)->rchild, e, taller))
                    return FALSE;//未插入
                }
                if (*taller)
                { //以插入到T的右子树且右子树“长高”
                    switch ((*T)->bf)
                    {        //检查T的平衡度
                    case LH: //原本左子树比右子树高，现左右子树等高
                        (*T)->bf = EH;*taller = FALSE;break;
                    case EH: //原本左子树与右子树等高，现因右子树增高而增高
                        (*T)->bf = RH;*taller = TRUE;break;
                    case RH: //原本右子树比左子树高，右平衡处理
                        RightBalance(T);*taller = FALSE;break;
                    }
                }
            }
        }
        return TRUE;
    }
    ```

  - 算法实现

    - `T`为空，申请内存，插入新结点
    - `T`不空
      - 当`e`小于`T`的根节点值，则在`T`的左子树查找，递归调用此函数
        - `*taller=FALSE*`，存在数据元素为`e`的结点，不插入
        - `*taller=TRUE*`，不存在数据元素为`e`的结点，插入
          - `T->bf=1`，左平衡旋转
          - `T->bf=0||T->bf=-1`，修改对应结点`BF`值即可
      - 当`e`大于`T`的根节点值，则在`T`的右子树查找，递归调用此函数
        - `*taller=FALSE*`，存在数据元素为`e`的结点，不插入
        - `*taller=TRUE*`，不存在数据元素为`e`的结点，插入
          - `T->bf=-1`，右平衡旋转
          - `T->bf=0||T->bf=1`，修改对应结点`BF`值即可

- 创建平衡二叉树

  - ```c
    int i;
    int a[10] = {3, 2, 1, 4, 5, 6, 7, 10, 9, 8};
    BiTree T = NULL;
    Status taller;
    for (i = 0; i < 1; i++)
    {
        InsertAVL(&T, a[i], &taller);
    }
    ```

    

### 8.7.多路查找树（B树）

#### 8.7.1.2-3树

- 多路查找树（Mutil-Way Search Tree）：其每一个结点孩子数可以多于亮哥，且每一个结点可以存储多个数据元素；由于它是查找树，所有元素之间存在某种特定的排序关系

- 2-3树：是多路查找树，每一个结点都具有两个孩子（称为2结点）或三个孩子（称为3结点）

  - 一个2结点包含一个元素和两个孩子（或没有孩子）；左子树小于该元素，右子树大于该元素；2结点要么没有孩子，要么必须有两个孩子

  - 一个3结点包含一小一大两个元素和三个孩子（或没有孩子）；左子树小于小元素，右子树大于大元素，中间子树介于两元素之间；3结点要么没有孩子，要么必须有三个孩子

  - 2-3树所有叶子节点必须在同一层上

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-533d3f37ad334df79bf33f7ed4aac741-109-017003.png" alt="1" style="zoom: 35%;"/>

- 2-3树的插入实现（2-3树插入的三种情况）

  - 空树：插入一个2结点即可

  - 插入元素到一个2结点上：将该叶子结点由2结点变成3结点；比较大小，确定左右

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-3f4f306e7660450273fda7c4a84b2896-110-b7891c.png" alt="1" style="zoom: 40%;"/>

  - 插入元素到一个3结点上：将3结点元素拆分，且将树中两元素和插入元素三者其一向上移动

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-10ee8c8ce1e21451b4156a3da20a9ce2-111-144b1b.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-32e0886d04bd5721821b486fdcd8954e-112-7262b2.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-159d2d37fb80a215b00b8f6eef7df1c7-113-edfbf4.png" alt="1" style="zoom: 40%;"/>

- 2-3树的删除实现（2-3树删除的三种情况）

  - 删除元素位于一个3结点上：删除该元素即可

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-c21802c57fbdbc74547d4e7679732413-114-240556.png" alt="1" style="zoom: 40%;"/>

  - 删除元素位于一个2节点上

    - 此结点的双亲是2结点，且双亲结点的右孩子是3结点

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-d4160d75530a0f127bcb14fe9a027894-115-dd30f4.png" alt="1" style="zoom: 40%;"/>

    - 此结点的双亲是2结点，且双亲结点的右孩子是2结点

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-5eb95d6d27901c13244e57320ab937ae-116-2ff7d9.png" alt="1" style="zoom: 40%;"/>

    - 此结点的双亲是3结点

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-8202e7f186efbabddc65d3836f794846-117-3d5826.png" alt="1" style="zoom: 40%;"/>

    - 当前树是满二叉树

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-e8f462ea56b739abca53438e95dc96f0-118-6fb9be.png" alt="1" style="zoom: 40%;"/>

  - 删除元素位于非叶子的分支结点上：通常中序遍历找到此元素的前驱或后继，考虑让他们补位

    - 此元素位于2结点

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-239eabf86efb4053fd834f8a34d82fe0-119-920383.png" alt="1" style="zoom: 40%;"/>

    - 此元素位于3结点

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-9475da7669f7c415ec20028ca0dc536d-120-e737ba.png" alt="1" style="zoom: 40%;"/>

- 2-3-4树：2-3树的扩展，包括了4结点的使用

  - 一个4结点包含小中大三个元素和四个孩子；左子树小于小元素，第二子树大于小元素小于中元素，第三子树大于中元素小于大元素，右子树大于大元素；4结点要么没有孩子，要么必须有四个孩子

#### 8.7.2.B树

- B树（B-Tree）：B树是一棵平衡的多路查找树（2-3树和2-3-4树是B树的特例）；结点最大的孩子数目称为B树的阶（order）；2-3树即为3阶B树

- m阶B树

  - 如果根结点不是叶子节点，则其至少由两棵子树

  - 每一个非根的分支结点都有k-1个元素和k个孩子，其中$[m/2]<=k<=m；每一个叶子节点n都有k−1个元素，其中；每一个叶子节点n都有k-1个元素，其中[m/2]<=k<=m$

  - 所有叶子结点都位于同一层上

  - 所有分支结点包含下列信息数据(n,A0,K1,A1,K2,A2,…,Kn,An)(n,A_0,K_1,A_1,K_2,A_2,\dots,K_n,A_n)；KiK_i为关键字，且Ki<Ki+1K_i<K_{i+1}；AiA_i为指向子树根结点的指针，且指针Ai−1A_{i-1}所指子树中所有结点的关键字均小于KiK_i；AnA_{n}所指子树中所有结点的关键字均大于KnK_n；$n([m/2]<=n<=m)$为关键字的个数

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-3a38d556be3115039bc9ed0556c34ce2-121-56c324.png" alt="1" style="zoom: 40%;"/>

- B+树：原有的B树结构基础上，加了新的元素组织方式

  - 一棵m阶B+树与m阶B树的差异

    - 有n棵子树的结点包含有n个关键字
    - 所有叶子结点包含全部关键信息，及指向含这些关键字记录的指针，叶子节点本身依关键字的大小自小而大顺序链接
    - 所有分支结点可以看成索引，结点中仅含有其子树的最大（或最小）关键字

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-703d157420530dca09e46d42e9fa994e-122-209285.png" alt="1" style="zoom: 40%;"/>



### 8.8.散列表查找（哈希表）

#### 8.8.1.散列表查找概述

- 散列技术：在记录的存储位置和它的关键字之间建立一个确定的对应关系ff，使得每个关键字keykey对应一个存储位置f(key)f(key)
  - 存储位置=f(key)存储位置=f(key)
  - ff称为散列函数，又称为哈希（Hash）函数
  - 哈希表：采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash Table）
- 散列表查找步骤
  - 在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录
  - 在查找时，通过散列函数计算记录的散列地址，并按此散列地址访问该记录
- 散列表
  - 散列表既是一种存储方法，也是一种查找方法
  - 散列技术适合求解查找与给定值相等的记录
  - 散列技术不适合一个关键字对应很多记录的情形，也不适合范围查找
  - 冲突：两个关键字key1≠key2key_1\neq key_2，但f(key1)=f(key2)f(key_1)=f(key_2)，这种现象称为冲突（collision），key1,key2key_1,key_2称为这个散列函数的同义词（synonym）

#### 8.8.2.散列函数的构造方法

- 散列函数构造原则

  - 计算简单
  - 散列地址分布均匀

- 直接定址法

  - f(key)=a∗key+bf(key)=a*key+b

  

- 数字分析法

  - 关键字是位数较多的数字（如手机号），用抽取方法计算散列存储的位置
  - 示例（手机号）
    - 前三位为运营公司
    - 中间四位为HLR，表示用户所属地
    - 后四位为用户号

- 平方取中法

  - 关键字平方，取平方后的中间几位作散列地址
  - 示例：`1234`，平方后为`1522756`，可取`227`作散列地址

- 折叠法

  - 将关键字从左到右分割成位数相等的几部分（最后部分不够可短），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址
  - 示例：`987654321`，分割`987|654|321|0`，叠加`987+654+321+0=1962`，后3位`962`作散列地址

- 除留余数法

  - $f(key)=key\;\; mod \;\;p\quad(p<=m)$（m为表长)
  - 可直接取模，也可在折叠、平方取中后取模
  - 选取合适的pp是关键，通常为小于或等于表长（最好接近表长）的最小质数或不包含小于20质因子的合数

- 随机数法

  - f(key)=random(key)f(key)=random(key)
  - 使用与关键字的长度不等的情形

- 散列函数选取时考虑的因素：计算散列地址所需时间；关键字长度；散列表的大小；关键字的分布情况；记录查找的频率

#### 8.8.3.处理散列冲突的方法

- 开放定址法

  - 一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列表总能找到，并将记录存入
  - $f_i(key)=(f(key)+d_i)\;\;MOD\;\;m(d_i=1,2,\dots m-1)$

- 示例：$\{12,67,56,16,25,37,22,29,15,47,48,34\};f(key)=key\;\;mod\;\;12$

  - 前5个数没有冲突，直接存入

  | 下标    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
  | ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | **key** | 12   | 25   |      |      | 16   |      |      | 67   | 56   |      |      |      |

  - key=37,f(37)=1key=37,f(37)=1，发生冲突；应用公式$f(37)=(f(37)+1)\;\;mod\;\;12=2$

  | 下标    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
  | ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | **key** | 12   | 25   | 37   |      | 16   |      |      | 67   | 56   |      |      |      |

  - 接下来4位没有冲突，直接存入

  | 下标    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
  | ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | **key** | 12   | 25   | 37   | 15   | 16   | 29   |      | 67   | 56   |      | 22   | 47   |

  - key=48,f(48)=0key=48,f(48)=0，发生冲突；应用公式$f(48)=(f(48)+1)\;\;mod\;\;12=1，冲突，，冲突，f(48)=(f(48)+2)\;\;mod\;\;12=2，冲突······直到，冲突······直到f(48)=(f(48)+6)\;\;mod\;\;12=6$，存入

  | 下标    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
  | ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | **key** | 12   | 25   | 37   | 15   | 16   | 29   | 48   | 67   | 56   |      | 22   | 47   |

  - key=34,f(34)=10key=34,f(34)=10，发生冲突；应用公式，但后面已经没有位置了，前面有位置，为提高效率，对公式进行改进

    $f_i(key)=(f(key)+d_i)\;\;MOD\;\;m(d_i=1^2,-1^2,2^2,-2^2,\dots q^2,-q^2\quad q<=m/2)$

    $f(34)=(f(34)+1)\;\;mod\;\;12=11，冲突，，冲突，f(34)=(f(34)-1)\;\;mod\;\;12=9$，存入

  | 下标    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
  | ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | **key** | 12   | 25   | 37   | 15   | 16   | 29   | 48   | 67   | 56   | 34   | 22   | 47   |

- 开放定址法改进

  - 二分探测法

    $f_i(key)=(f(key)+d_i)\;\;MOD\;\;m(d_i=1^2,-1^2,2^2,-2^2,\dots q^2,-q^2\quad q<=m/2)$

  - 随机探测法：在冲突时，did_i才有随机函数获得；此随机数为伪随机数，设置固定的随机种子，得到随机数列数列；查找时，用相同的随机种子生成数列，该数列与之前的随机数列相同

    $f_i(key)=(f(key)+d_i)\;\;MOD\;\;m(d_i是随机数列)$

- 再散列函数法

  - fi(key)=RHi(key)(i=1,2,…,k)f_i(key)=RH_i(key)\quad(i=1,2,\dots,k)
  - 事先准备多个散列函数，发生冲突时更换散列函数

- 链地址法

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-45b12190d8607e4e8b5ba7072c20bcd7-123-30baf6.png" alt="1" style="zoom: 40%;"/>

  

- 公共溢出区法

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-6e697f91394e544813c37cecae54bc4c-124-2a4dc4.png" alt="1" style="zoom: 40%;"/>

#### 8.8.4.散列表查找实现

- 散列表结构

  - ```c
    #define SUCCESS 1
    #define UNSUCESS 0
    #define HASHSIZE 12 //定义散列表长为数组的长度
    #define NULLKEY -32768
    typedef struct
    {
        int *elem; //数据元素存储基址，动态分配数组
        int count; //当前数据元素个数
    } HashTable;
    int m = 0; //散列表表长，全局变量
    ```

- 散列表初始化

  - ```c
    //散列表初始化
    Status InitHashTable(HashTable *H)
    {
        int i;
        m = HASHSIZE;
        H->count = m;
        H->elem = (int *)malloc(m * sizeof(int));
        for (i = 0; i < m; i++)
        {
            H->elem[i] = NULLKEY;
        }
        return OK;
    }
    ```

- 散列函数

  - ```c
    //散列函数
    int Hash(int key)
    {
        return key % m; //除留余数法
    }
    ```

- 散列表插入操作

  - ```c
    //插入关键字进散列表
    void InsertHash(HashTable *H, int key)
    {
        int addr = Hash(key); //求散列地址
        while (H->elem[addr] != NULLKEY)
        {                          //如果不为空，则冲突
            addr = (addr + 1) % m; //开放地址法的线性探测
        }
        H->elem[addr] = key; //直到有空位后插入关键字
    }
    ```

- 散列表查找

  - ```c
    //散列表查找关键字
    Status SearchHash(HashTable H, int key, int *addr)
    {
        *addr = Hash(key); //求散列地址
        while (H.elem[*addr] != key)
        {
            *addr = (*addr + 1) % m; //开放地址法的线性探测
            if (H.elem[*addr] == NULLKEY || *addr == Hash(key))
            {                    //如果循环回到原点
                return UNSUCESS; //关键字不存在
            }
        }
        return SUCCESS;
    }
    ```

    - 时间复杂度：**O(1)**

- 散列表查找性能分析

  - 散列函数是否均匀
  - 处理冲突的方法
  - 散列表的装填因子（α\alpha）：α=填入表中的记录个数/散列表长度\alpha=填入表中的记录个数/散列表长度；表示装满的程度，值越大，产生冲突的可能性就越大

-----



## 9.排序

### 9.1.排序的概念与分类

- 排序：假设含有n个记录的序列$\{r_1,r_2,\dots,r_n\}，其相应的关键字，其相应的关键字\{k_1,k_2,\dots,k_n\}，需确定一种排列，需确定一种排列\{p_1,p_2,\dots,p_n\}使其相应的关键字满足使其相应的关键字满足\{k_{p1}<=k_{p2}<=\dots<=k_{pn}\}非递减（或非递增）关系，即使得序列成为一个按关键字有序的序列非递减（或非递增）关系，即使得序列成为一个按关键字有序的序列\{r_{p1},r_{p2},\dots,r_{pn}\}$，这样的操作成为排序
- 排序的稳定性：假设ki=kjk_i=k_j，且在排序前的序列rir_i领先于rjr_j（即i<ji<j）；若排序后rir_i仍领先于rjr_j，则称所用的排序方法是稳定的；反之，则不稳定
- 排序的分类
  - 内排序：在排序的整个过程中，待排序的所有记录全部被防止在内存中
    - 影响性能的因素
      - 时间性能
      - 辅助空间
      - 算法的复杂性
    - 内排序分为：插入排序，交换排序，选择排序，归并排序
  - 外排序：由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要内外存之间多次交换数据才能进行

- 排序用到的结构（顺序表结构）

  - ```c
    #define MAXSIZE 10 //用于要排序数组个数的最大值
    typedef struct
    {
        int r[MAXSIZE + 1]; //用于存储要排序数组，r[0]用作哨兵或临时变量
        int length;         //用于记录顺序表的长度
    } SqList;
    ```

- 交换函数

  - ```c
    //交换L中数组r的下标为i和j的值
    void swap(SqList *L, int i, int j)
    {
        int temp = L->r[i];
        L->r[i] = L->r[j];
        L->r[j] = temp;
    }
    ```



### 9.2.冒泡排序

- 冒泡排序（Bubble Sort）：一种交换排序；两两比较相邻记录的关键字，如果反序则交换，直到没有反序为止

  

- 简单的交换排序

  - ```c
    //对顺序表L作交换排序（冒泡排序初级版）
    void BubbleSort0(SqList *L)
    {
        int i, j;
        for (i = 1; i < L->length; i++)
        {
            for (j = i + 1; j <= L->length; j++)
            {
                if (L->r[i] > L->r[j])
                {
                    swap(L, i, j); //交换L->r[i]与L->r[j]的值
                }
            }
        }
    }
    ```

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-ef9428513e2fd083e6a78c021cf340a3-125-b2fed2.png" alt="1" style="zoom: 40%;"/>

  - 不算是标准的冒泡排序，不满足“两两比较相邻记录”，只是简单的交换排序

- 冒泡排序算法

  - ```c
    //对顺序表L作冒泡排序
    void BubbleSort1(SqList *L)
    {
        int i, j;
        for (i = 1; i < L->length; i++)
        {
            for (j = L->length - 1; j >= i; j--)
            { //注意j是从后往前排序
                if (L->r[j] > L->r[j + 1])
                {                      //若前者大于后者
                    swap(L, j, j + 1); //交换L->r[j]与L->r[j+1]的值
                }
            }
        }
    }
    ```

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-c2c37ce568e18b6fe7ea50a7d5e34540-126-a0e99b.png" alt="1" style="zoom: 40%;"/>

- 冒泡排序优化

  - 序列已经有序，不需继续循环

  - 增加一个标记变量flag

  - ```c
    //对顺序表L作改进冒泡排序
    void BubbleSort2(SqList *L)
    {
        int i, j;
        Status flag = TRUE; // flag用来作为标记
        for (i = 1; i < L->length && flag; i++)
        {
            flag = FALSE; //初始为false
            for (j = L->length - 1; j >= i; j--)
            { //注意j是从后往前排序
                if (L->r[j] > L->r[j + 1])
                {                      //若前者大于后者
                    swap(L, j, j + 1); //交换L->r[j]与L->r[j+1]的值
                    flag = TRUE;       //如果有数据交换，则flag为true
                    				   //没有数据交换说明已经排好了
                }
            }
        }
    }
    ```



### 9.3.简单选择排序

- 简单选择排序算法（Simple Selection Sort）：通过`n-i`次关键字间的比较，从`n-i+1`个记录中选出关键字最小的记录，并和第`i`个记录交换之

  

  - ```c
    //对顺序表L作简单选择排序
    void SelectSort(SqList *L)
    {
        int i, j, min;
        for (i = 1; i < L->length; i++)
        {
            min = i; //将当前下标定义为最小值下标
            for (j = i + 1; j <= L->length; j++)
            { //循环之后的数据
                if (L->r[min] > L->r[j])
                {            //如果有小于最小值的关键字
                    min = j; //将此关键字的下标赋值给min
                }
            }
            if (i != min)
            { //若min不等于i，说明找到最小值，交换
                swap(L, i, min);
            }
        }
    }
    ```

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-194167aae3bf51b68aace0c8c900935c-127-839219.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-258057b7575eeaddfb6ba98633d4568d-128-be577f.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-b2971e4b28ffa935cf9fc5bd45d8286e-129-67492f.png" alt="1" style="zoom: 40%;"/>



### 9.4.直接插入排序

- 直接插入排序算法（Straight Insertion Sort）：将一个记录插入到已经排好序的有序表中，从而得到一个新的记录数增1的有序表

  

  - ```c
    //对顺序表L作直接插入排序
    void InsertSort(SqList *L)
    {
        int i, j;
        for (i = 2; i <= L->length; i++)
        {
            if (L->r[i] < L->r[i - 1])
            {                      //需将L->r[i]插入有序子表
                L->r[0] = L->r[i]; //设置哨兵
                for (j = i - 1; L->r[j] > L->r[0]; j--)
                {
                    L->r[j + 1] = L->r[j]; //记录后移
                }
                L->r[j + 1] = L->r[0]; //插入到正确位置
            }
        }
    }
    ```

    - 每次循环保证当前数组有序

  - 示例`{0,5,3,4,6,2}`

    - 初始状态

      | 0(L.r[0]) | 5    | 3    | 4    | 6    | 2    |
      | --------- | ---- | ---- | ---- | ---- | ---- |

    - `i=2`：`3`比`5`小，`5`后移

      | 3(L.r[0]) | 3    | 5    | 4    | 6    | 2    |
      | --------- | ---- | ---- | ---- | ---- | ---- |

    - `i=3`：`4`比`5`小，`5`后移；`4`比`3`大，`3`不移

      | 4(L.r[0]) | 3    | 4    | 5    | 6    | 2    |
      | --------- | ---- | ---- | ---- | ---- | ---- |

    - `i=4`：`6`比`5`大，`6`不移

      | 6(L.r[0]) | 3    | 4    | 5    | 6    | 2    |
      | --------- | ---- | ---- | ---- | ---- | ---- |

    - `i=5`：`2`比`6`小，`6`后移，`2`比`5`小，`5`后移，`2`比`4`小，`4`后移，`2`比`3`小，`3`后移

      | 2(L.r[0]) | 2    | 3    | 4    | 5    | 6    |
      | --------- | ---- | ---- | ---- | ---- | ---- |



### 9.5.希尔排序

- 基本有序：小的关键字基本在前面，大的关键字基本在后面（`{2,1,3,6,4,7,5,8,9}`）

- 将相距某个“增量”的记录组成一个子序列，保证直接插入排序后基本有序

  

- 希尔排序

  - ```c
    //对顺序表L作希尔排序
    void ShellSort(SqList *L)
    {
        int i, j;
        int increment = L->length;
        do
        {
            increment = increment / 3 + 1; //增量序列
            for (i = increment + 1; i <= L->length; i++)
            {
                if (L->r[i] < L->r[i - increment])
                {                      //需将L->r[i]插入有序增量子表
                    L->r[0] = L->r[i]; //暂存在L->r[0]
                    for (j = i - increment; j > 0 && L->r[0] < L->r[j]; j -= increment)
                    {
                        L->r[j + increment] = L->r[j]; //记录后移，查找插入位置
                    }
                    L->r[j + increment] = L->r[0]; //插入
                }
            }
        } while (increment > 1);
    }
    ```

  - 算法实现

    - 设置增量`increment`

    - 比较`L[i-increment]`与`L[i]`（从`L[1]`和`L[increment+1]`开始，一直比较到`L[n-increment]`和`L[n]`）

      - 将`L[i]`存在`L[0]`处
      - 比较`L[i-increment]`与`L[i]`，若`L[i-increment]`比`L[i]`大，交换值
      - 从`L[i-increment]`向前找距其`k*increment(k=1,2,...)`位置的值，若比`L[i]`大，交换值，循环此步，直至到头

    - 修改增量，重复上述步骤

    - ```c
      9,1,5,8,3,7,4,6,2    
      increment=4     9,1,5,8,3,7,4,6,2
      i=5	    		9,1,5,8,9,7,4,6,2
      	    		3,1,5,8,9,7,4,6,2
      i=7	    		3,1,5,8,9,7,5,6,2
      				3,1,4,8,9,7,5,6,2
      i=8				3,1,4,8,9,7,5,8,2
      				3,1,4,6,9,7,5,8,2
      i=9				3,1,4,6,9,7,5,8,9
      				3,1,4,6,3,7,5,8,9
      				2,1,4,6,3,7,5,8,9
      increment=2     2,1,4,6,3,7,5,8,9
      i=5				2,1,4,6,4,7,5,8,9
      				2,1,3,6,4,7,5,8,9
      increment=1		2,1,3,6,4,7,5,8,9
      i=2				2,2,3,6,4,7,5,8,9
      				1,2,3,6,4,7,5,8,9
      i=5				1,2,3,6,6,7,5,8,9
      				1,2,3,4,6,7,5,8,9
      i=7				1,2,3,4,6,7,7,8,9
      				1,2,3,4,6,6,7,8,9
      				1,2,3,4,5,6,7,8,9
      i=9				1,2,3,4,5,6,7,8,9
      ```

  - 希尔排序不稳定



### 9.6.堆排序

- 堆：完全二叉树，每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-120fc72775790cc567da3bab809eca7e-130-906cb0.png" alt="1" style="zoom: 30%;"/>

  - 层序遍历满足$\begin{cases}k_i>=k_{2i}\\k_i>=k_{2i+1}\end{cases}或\begin{cases}k_i<=k_{2i}\\k_i<=k_{2i+1}\end{cases}1<=i<=[\frac{n}{2}]$

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-60c1c04093ea3b25fd6d24c408c4f595-131-9c497a.png" alt="1" style="zoom: 35%;"/>

- 堆排序（Heap Sort）：将待排序的序列构成一个大顶堆；此时，整个序列的最大值就是堆顶的根结点；将它移走（将其与堆数组末尾元素交换，此时末尾就是最大值），然后将n-1个序列重新构成一个堆，得到n个元素中的次大值（n-1个元素中的最大值）；如此反复，得到一个有序序列

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-7c2ab8a6df417c6d922a24858e7ee37b-132-430552.png" alt="1" style="zoom: 35%;"/>

  <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-9b1e752ea621409a7ad51cf4ec9d8db2-133-ef37b4.png" alt="1" style="zoom: 35%;"/>

  

  - ```c
    //对顺序表L进行堆排序
    void HeapSort(SqList *L)
    {
        int i;
        for (i = L->length / 2; i > 0; i--)
        { //把L中的r构成一个大顶堆
            HeapAdjust(L, i, L->length);
        }
        for (i = L->length; i > 1; i--)
        {
            swap(L, 1, i);           //将堆顶记录和当前未经排序子序列的最后一个记录交换
            HeapAdjust(L, 1, i - 1); //将L->r[1...i-1]重新调整为大顶堆
        }
    }
    ```

    - 第一个循环将待排序序列构建成一个大顶堆，`i = L->length / 2`找到有孩子的结点（即分支结点），由此构建大顶堆

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-6ed890bbd74e660397107e43f6d513e9-134-4bd7b6.png" alt="1" style="zoom: 40%;"/>

    - 第二个循环逐步将每个最大值的根结点与末尾元素交换，并再次构建成大顶堆

    - 堆排序不稳定

  - ```c
    //已知L->r[s...m]中记录的关键字除L->r[s]之外均满足对的定义
    //调整L->r[s]的关键字，使L->r[s...m]构成一个大顶堆
    void HeapAdjust(SqList *L, int s, int m)
    {
        int temp, j;
        temp = L->r[s];
        for (j = 2 * s; j <= m; j *= 2)
        { //沿关键字较大的孩子结点向下筛选
            if (j < m && L->r[j] < L->r[j + 1])
            {
                ++j; // j为关键字中较大记录的下标
            }
            if (temp >= L->r[j])
            {
                break; // 最大值已经在堆顶，不进行位置更换
            }
            L->r[s] = L->r[j];
            s = j;
        }
        L->r[s] = temp; //插入
    }
    ```

    - 对有孩子的结点进行根结点与孩子结点大小的比较，若左右孩子结点比根结点大，将较大的放入分支结点，若左右孩子结点比根结点小，不进行位置更换

      - 未构建大顶堆前

        <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-3c02eace748b7107f93ace010ec1fe78-135-cb8397.png" alt="1" style="zoom: 35%;"/>

      - 构建后

        <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-8679a0449ae166814d26faaa9f1ab0ab-136-3cb662.png" alt="1" style="zoom: 30%;"/>



### 9.7.归并排序

- 归并排序（Merging Sort）：假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两合并，得到⌈n/2⌉\lceil n/2 \rceil（向上取整）个长度为2或1的有序子序列，在两两合并······如此重复，直至得到一个长度为n的有序序列为止，这种排序称为2路归并排序

- 递归归并排序

  - ```c
    //对顺序表L作归并排序（递归）
    void MergeSort1(SqList *L)
    {
        MSort(L->r, L->r, 1, L->length);
    }
    ```

  - ```c
    //将SR[s...t]归并排序为TR1[s...t]（递归）
    void MSort(int SR[], int TR1[], int s, int t)
    {
        int m;
        int TR2[MAXSIZE];
        if (s == t)
        {
            TR1[s] = SR[s];
        }
        else
        {
            m = (s + t) / 2;      //将SR[s..t]平分为SR[s...m]和SR[m+1..t]
            MSort(SR, TR2, s, m);    //递归将SR[s..m]归并为有序的TR2[s..m]
            MSort(SR, TR2, m + 1, t);//递归将SR[m+1..t]归并为有序的TR2[m+1..t]
            Merge(TR2, TR1, s, m, t);//将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t]
        }
    }
    ```

    - 归并排序是稳定的

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-2fb3ba1d1aaab072a241e56387d236b2-137-0511a1.png" alt="1" style="zoom: 40%;"/>

  - ```c
    //将有序的SR[i...m]和SR[m+1...n]归并为有序的TR[i...n]
    void Merge(int SR[], int TR[], int i, int m, int n)
    {
        int j, k, l;
        for (j = m + 1, k = i; i <= m && j <= n; k++)
        { //将SR中的记录由小到大归并入TR
            if (SR[i] < SR[j])
            {
                TR[k] = SR[i++];
            }
            else
            {
                TR[k] = SR[j++];
            }
        }
        if (i <= m)
        {
            for (l = 0; l <= m - i; l++)
            {
                TR[k + l] = SR[i + l]; //将剩余的SR[i...m]复制到TR
            }
        }
        if (j <= n)
        {
            for (l = 0; l <= n - j; l++)
            {
                TR[k + l] = SR[j + l]; //将剩余的SR[j...n]复制到TR
            }
        }
    }
    ```

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-ce66ac7a5c6e2911b1f44438a80833e5-138-a553d7.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-7270b0e28294447bacce4198db4633f8-139-a955bf.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-e3e652f03ff5c0e050e4c47bdcbc693e-140-1067f2.png" alt="1" style="zoom: 40%;"/>

- 非递归归并排序

  - ```c
    //对顺序表L作归并排序（非递归）
    void MergeSort2(SqList *L)
    {
        int *TR = (int *)malloc(L->length * sizeof(int)); //申请额外空间
        int k = 1;
        while (k < L->length)
        {
            MergePass(L->r, TR, k, L->length);
            k = 2 * k; //子序列长度加倍
            MergePass(TR, L->r, k, L->length);
            k = 2 * k; //子序列长度加倍
        }
    }
    ```

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-b85027ede65180cf8c68c23b4e841892-141-0e6e00.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-9eaa38183405467a327485ee26557f44-142-80978f.png" alt="1" style="zoom: 40%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-e5d779a2863b672e5a0f4fc7cd73cde6-143-bfa627.png" alt="1" style="zoom: 40%;"/>

  - ```c
    //将SR[]中相邻长度为s的子序列两两归并到TR[]
    void MergePass(int SR[], int TR[], int s, int n)
    {
        int i = 1;
        int j;
        while (i <= n - 2 * s + 1)
        {
            Merge(SR, TR, i, i + s - 1, i + 2 * s - 1); //两两归并
            i = i + 2 * s;
        }
        if (i < n - s + 1)
        { //归并最后两个序列
            Merge(SR, TR, i, i + s - 1, n);
        }
        else
        { //若最后只剩下单个子序列
            for (j = i; j <= n; j++)
            {
                TR[j] = SR[j];
            }
        }
    }
    ```



### 9.8.快速排序

- 快速排序（Quick Sort）：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的

  - ```c
    //对顺序表L作快速排序
    void QuickSort0(SqList *L)
    {
        QSort0(L, 1, L->length);
    }
    ```

  - ```c
    //对顺序表L中的子序列L->r[low..high]作快速排序
    void QSort0(SqList *L, int low, int high)
    {
        int pivot;
        if (low < high)
        {
            pivot = Partition0(L, low, high); //将L->r[low..high]一分为二算出枢轴值pivot
            QSort0(L, low, pivot - 1);        //对低子表递归排序
            QSort0(L, pivot + 1, high);       //对高子表递归排序
        }
    }
    ```

  - `Partition`函数：选取一个关键字，将其放到一个位置，使得它左边的值都比它小，右边的值都比它大，将这样的关键字称为枢轴（pivot）

  - ```c
    //交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置
    //此时在它之前比它小，在它之后比它大
    int Partition0(SqList *L, int low, int high)
    {
        int privotkey;
        privotkey = L->r[low]; //用子表的第一个记录作枢轴记录
        while (low < high)
        {
            while (low < high && L->r[high] >= privotkey)
            {
                high--;
            }
            swap(L, low, high); //将比枢轴记录小的交换到低端
            while (low < high && L->r[low] <= privotkey)
            {
                low++;
            }
            swap(L, low, high); //将比枢轴记录大的交换到高端
        }
        return low; //返回枢轴所在位置
    }
    ```

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-fe8b7a4139a30caa624e90de0af57abb-144-2930ee.png" alt="1" style="zoom: 30%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-792f1692dd5fb586edd21098bd0d08c1-145-d100bb.png" alt="1" style="zoom: 30%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-7905c83bfa00afd459048c034d9ebabf-146-4bc59c.png" alt="1" style="zoom: 30%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-5af9a91440d52865c934e03d8524e457-147-3f8a33.png" alt="1" style="zoom: 30%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-28878665fcb7e6f6b1d41ee0154290a7-148-1c2afb.png" alt="1" style="zoom: 30%;"/>

    <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-3d42687ac31d3e86b86c586fcc641cce-149-0b5c22.png" alt="1" style="zoom: 30%;"/>

- 快速排序优化

  - 优化选取枢轴

    - 关键字应选取中间数
    - 随机选取法
    - 三数取中法：取三个关键字先进行排序，将中间数作为枢轴，一般取左端、右端和中间三个数（也可随机选取，但一般不予考虑）
    - 九数取中法：三次取样，每次取三个数，得到三个中间数，再从这三个数中取中间数

    ```c
    int privotkey;
    int m = low + (high - low) / 2; //计算中间元素的下标
    if (L->r[low] > L->r[high])
    {
        swap(L, low, high); //交换左端与右段的数据，保证左端较小
    }
    if (L->r[m] > L->r[high])
    {
        swap(L, high, m); //交换中间与右段的数据，保证中间较小
    }
    if (L->r[m] > L->r[low])
    {
        swap(L, m, low); //交换中间与左段的数据，保证中间较小
    }
    //此时L.r[low]为左中右端的中间值
    
    privotkey = L->r[low]; //用子表的第一个记录作枢轴记录
    ```

  - 优化不必要的交换

    - 采用替换优化交换

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-20c1328045f6423d6f01dd8f0fb5d8e5-150-62c265.png" alt="1" style="zoom: 30%;"/>

      <img src="https://cdn.jsdelivr.net/gh/JacobSuCHN/blog-img/img/jssx-ds%2F2024%2F02%2F24%2F09-48-58-4101573a871210e8a45ec7ecf32ca7fc-151-9b5c95.png" alt="1" style="zoom: 30%;"/>

    ```c
    //交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置
    //此时在它之前比它小，在它之后比它大
    int Partition1(SqList *L, int low, int high)
    {
        int privotkey;
        int m = low + (high - low) / 2; //计算中间元素的下标
        if (L->r[low] > L->r[high])
        {
            swap(L, low, high); //交换左端与右段的数据，保证左端较小
        }
        if (L->r[m] > L->r[high])
        {
            swap(L, high, m); //交换中间与右段的数据，保证中间较小
        }
        if (L->r[m] > L->r[low])
        {
            swap(L, m, low); //交换中间与左段的数据，保证中间较小
        }
        //此时L.r[low]为左中右端的中间值
    
        privotkey = L->r[low]; //用子表的第一个记录作枢轴记录
        L->r[0] = privotkey;   //将枢轴关键字备份到L->r[0]
        while (low < high)
        {
            while (low < high && L->r[high] >= privotkey)
            {
                high--;
            }
            L->r[low] = L->r[high]; //采用替换而不是交换的方式进行操作
            while (low < high && L->r[low] <= privotkey)
            {
                low++;
            }
            L->r[high] = L->r[low]; //采用替换而不是交换的方式进行操作
        }
        L->r[low] = L->r[0]; //将枢轴值替换回L.r[low]
        return low;          //返回枢轴所在位置
    }
    ```

    

  - 优化小数组的排序方法
  
    - 小数组时快速排序因递归操作可能性能比不如插入排序
    - 小数组时用插入排序
  
    ```c
    #define MAX_LENGTH_INSERT_SORT 7 //数组长度阈值
    //对顺序表L中的子序列L->r[low..high]作快速排序
    void QSort1(SqList *L, int low, int high)
    {
        int pivot;
        if ((high - low) > MAX_LENGTH_INSERT_SORT)
        {                                    //当high-low大于阈值时用快速排序
            pivot = Partition(L, low, high); //将L->r[low..high]一分为二算出枢轴值pivot
            QSor1t(L, low, pivot - 1);        //对低子表递归排序
            QSort1(L, pivot + 1, high);       //对高子表递归排序
        }
        else
        { //当high-low小于等于阈值时用插入排序
            InsertSort(L);
        }
    }
    ```

  - 优化递归操作

    - 减少递归，实施尾递归优化
  
    ```c
    //对顺序表L中的子序列L->r[low..high]作快速排序
    void QSort1(SqList *L, int low, int high)
    {
        int pivot;
        if ((high - low) > MAX_LENGTH_INSERT_SORT)
        { //当high-low大于阈值时用快速排序
            while (low < high)
            {
                pivot = Partition(L, low, high); //将L->r[low..high]一分为二算出枢轴值pivot
                QSort1(L, low, pivot - 1);       //对低子表递归排序
                low = pivot + 1;                 //尾递归
            }
        }
        else
        { //当high-low小于等于阈值时用插入排序
            InsertSort(L);
        }
    }
    ```



### 9.9.排序总结

- 排序
  - 插入排序类：直接插入排序，希尔排序
  - 选择排序类：简单选择排序，堆排序
  - 交换排序类：冒泡排序，快速排序
  - 归并排序类：归并排序

| 排序方法     | 平均情况                  | 最好情况           | 最欢情况         | 辅助空间     | 稳定性 |
| ------------ | ------------------------- | ------------------ | ---------------- | ------------ | ------ |
| 冒泡排序     | O(n<sup>2</sup>)          | O(n)               | O(n<sup>2</sup>) | O(1)         | 稳定   |
| 简单选择排序 | O(n<sup>2</sup>)          | O(n<sup>2</sup>)   | O(n<sup>2</sup>) | O(1)         | 稳定   |
| 直接插入排序 | O(n<sup>2</sup>)          | O(n)               | O(n<sup>2</sup>) | O(1)         | 稳定   |
| 希尔排序     | O(nlogn)-O(n<sup>2</sup>) | O(n<sup>1.3</sup>) | O(n<sup>2</sup>) | O(1)         | 不稳定 |
| 堆排序       | O(nlogn)                  | O(nlogn)           | O(nlogn)         | O(1)         | 不稳定 |
| 归并排序     | O(nlogn)                  | O(nlogn)           | O(nlogn)         | O(n)         | 稳定   |
| 快速排序     | O(nlogn)                  | O(nlogn)           | O(n<sup>2</sup>) | O(logn)-O(n) | 不稳定 |

- 简单性
  - 简单算法：冒泡，简单选择，直接插入
  - 改进算法：希尔，堆，归并，快速

-----

