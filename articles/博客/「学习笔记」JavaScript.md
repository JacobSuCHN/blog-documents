## 1.JavaScript概述

### 1.1.概述

- JavaScript特点

  - 解释型语言：解释器边编译边执行

  - 函数式编程
  - 单线程
  - 面向对象
- JS的编写位置
  - 可以将js编写到网页内部的script标签
  - 可以将js编写外部的js文件中，然后通过script标签进行引入
  - 可以将js代码编写到指定属性中

### 1.2.数据

- 字面量
  - 字面量其实就是一个值，它所代表的含义就是它字面的意思
    - 比如：100 "hello" true null .....
    - 在js中所有的字面量都可以直接使用，但是直接使用字面量并不方便


- 变量

  - 变量可以用“存储”字面量

  - 并且变量中存储的字面量可以随意的修改

  - 通过变量可以对字面量进行描述，并且变量比较方便修改

  - 变量的使用 

    - 声明变量：let 变量名 / var 变量   

    - 变量赋值：a = xx
    - 声明和赋值同时进行：let 变量 = 值

- 常量

  - 在JS中，使用const声明常量，常量只能赋值一次，重复赋值会报错
  - 在JS中除了常规的常量外，有一些对象类型的数据我们也会声明为常量


### 1.3.命名规范


- 命名规范：
  - 通常会使用驼峰命名法
    - 首字母小写，每个单词开头大写
    - maxlength --> maxLength
    - borderleftwidth --> borderLeftWidth

  - 类名会使用大驼峰命名法
    - 首字母大写，每个单词开头大写
    - maxlength --> MaxLength

  - 常量的字母会全部大写
    - MAX_LENGTH

## 2.数据类型

### 2.1.原始值


- 数值（Number）

  - 在JS中所有的整数和浮点数都是Number类型
    限大的，当数值超过一定范围后会显示近似值
  - Infinity 是一个特殊的数值表示无穷
    精度比较高的运算时要十分注意
  - NaN 也是一个特殊的数值，表示非法的数值
  - 大整数（BigInt）
    - 大整数用来表示一些比较大的整数
    - 大整数使用n结尾，它可以表示的数字范围是无限大
- 字符串（String）

  - 在JS中使用单引号或双引号来表示字符串

  - 模板字符串
    - 使用反单引号` 来表示模板字符串
    - 模板字符串中可以嵌入变量
  - 使用typeof检查一个字符串时会返回 "string"
- 布尔值（Boolean）

  - 布尔值主要用来进行逻辑判断
  - 布尔值只有两个true 和 false
  - 使用typeof检查一个布尔值时会返回 "boolean"
- 空值 （Null）

  - 空值用来表示空对象
  - 空值只有一个 null
  - 使用typeof检查一个空值时会返回"object"
  - 使用typeof无法检查空值
- 未定义（Undefined）

  - 当声明一个变量而没有赋值时，它的值就是Undefined
  - Undefined类型的值只有一个就是 undefined
  - 使用typeof检查一个Undefined类型的值时，会返回 "undefined"
- 符号（Symbol）

  - 用来创建一个唯一的标识    
  - 使用typeof检查符号时会返回 "symbol"
- JS中原始值一共有七种

  - Number，BigInt，String，Boolean，Null，Undefined，Symbol
  - 七种原始值是构成各种数据的基石
  - 原始值在JS中是不可变类型，一旦创建就不能修改

### 2.2.typeof运算符

- typeof 运算符

  - ```javascript
    typeof 数据
    ```

  - typeof用来检查不同的值的类型

  - 它会根据不同的值返回不同的结果

### 2.3.类型转换


- 转换为字符串

  - 调用toString()方法将其他类型转换为字符串

    - ```javascript
      数据.toString()
      ```

    - 由于null和undefined中没有toString()，所以对这两个东西调用toString()时会报错

  - 调用String()函数将其他类型转换为字符串

    - ```javascript
      String(数据)
      ```

    - 原理

      - 对于拥有toString()方法的值调用String()函数时，实际上就是在调用toString()方法
      - 对于null，则直接转换为"null"
      - 对于undefined，直接转换为"undefined"

- 转换为数值

  - 使用Number()函数来将其他类型转换为数值

    - ```javascript
      Number(数据)
      ```

    - 转换的情况

      - 字符串
        - 如果字符串是一个合法的数字，则会自动转换为对应的数字
        - 如果字符串不是合法数字，则转换为NaN
        - 如果字符串是空串或纯空格的字符串，则转换为0
      - 布尔值
        - true转换为1，false转换为0
      - null 转换为 0
      - undefined 转换为 NaN

  - 专门用来将字符串转换为数值的两个方法                    

    - parseInt() ：将一个字符串转换为一个整数

      - ```javascript
        parseInt(字符串)
        ```

      - 解析时，会自左向右读取一个字符串，直到读取到字符串中所有的有效的整数

      - 也可以使用parseInt()来对一个数字进行取整        

    - parseFloat() ：将一个字符串转换为浮点数 

      - ```javascript
        parseFloat(数据)
        ```

      - 解析时，会自左向右读取一个字符串，直到读取到字符串中所有的有效的小数

- 转换为布尔值

  - 使用Boolean()函数来将其他类型转换为布尔值

    - ```javascript
      Boolean(数据)
      ```

  - 转换的情况

    - 数字
      - 0 和 NaN 转换为false
      - 其余是true
    - 字符串
      - 空串转换为 false
      - 其余是true
    - null和undefined 都转换为 false
    - 对象：对象会转换为true

  - 所有表示空的没有的错误的值都会转换为false：0、NaN、空串、null、undefined、false

  

## 3.对象

### 3.1.对象

- 数据类型

  - 原始值
    - 数值 Number
    - 大整数 BigInt
    - 字符串 String
    - 布尔值 Boolean
    - 空值 Null
    - 未定义 Undefined
    - 符号 Symbol
  - 对象
    - 对象是JS中的一种复合数据类型，            它相当于一个容器，在对象中可以存储各种不同类型数据
  - 原始值只能用来表示一些简单的数据，不能表示复杂数据

- 创建对象

  ```javascript
  let obj = Object()
  ```

- 对象中可以存储多个各种类型的数据， 对象中存储的数据，我们称为属性   

  - 向对象中添加属性

    - 对象.属性名 = 属性值

  - 读取对象中的属性

    - 对象.属性名

  - ```javascript
    obj.name = "孙悟空"
    obj.age = 18
    obj.gender = "男"
    ```

  - 如果读取的是一个对象中没有的属性，不会报错而是返回undefined

- 修改属性

  - ```javascript
    obj.name = "Tom sun"
    ```

- 删除属性

  - ```javascript
    delete obj.name
    ```


### 3.2.属性

- 属性名

  - 通常属性名就是一个字符串，所以属性名可以是任何值，没有什么特殊要求

  - 但是如果你的属性名太特殊了，不能直接使用，需要使用[]来设置

    - 虽然如此，但是我们还是强烈建议属性名也按照标识符的规范命名

  - 也可以使用符号（symbol）作为属性名，来添加属性，获取这种属性时，也必须使用symbol

    - 使用symbol添加的属性，通常是那些不希望被外界访问的属性

    - ```javascript
      // 使用symbol作为属性名
      let mySymbol = Symbol()
      obj[mySymbol] = "通过symbol添加的属性"
      ```

  - 使用[]去操作属性时，可以使用变量

    - ```javascript
      obj[str] = "花果山" // 等价于 obj["address"] = "花果山"
      ```

- 属性值

  - 对象的属性值可以是任意的数据类型，也可以是一个对象
  - 使用typeof检查一个对象时，会返回object

  - in 运算符
    - 用来检查对象中是否含有某个属性
    - 语法：属性名 in obj
    - 如果有返回true，没有返回false

### 3.3.对象字面量

- 对象字面量

  - 可以直接使用{} 来创建对象

  - 使用{}所创建的对象，可以直接向对象中添加属性

  - 语法

    - ```javascript
      {
      	属性名:属性值,
      	[属性名]:属性值,
      }
      ```

    - ```javascript
      let mySymbol = Symbol()
      let obj = {
          name:"孙悟空", 
          age:18,
          ["gender"]:"男",
          [mySymbol]:"特殊的属性",
          hello:{
              a:1,
              b:true
          }
      }
      ```

      

### 3.4.枚举属性

- 枚举属性

  - 指将对象中的所有的属性全部获取

  - for-in语句

    - ```javascript
      for(let propName in 对象){
      	语句...
      }
      ```

    - ```javascript
      for(let propName in obj){
          console.log(propName, obj[propName])
      }
      ```

    - for-in的循环体会执行多次，有几个属性就会执行几次，每次执行时，都会将一个属性名赋值给我们所定义的变量

    - 注意：并不是所有的属性都可以枚举，比如 使用符号添加的属性

### 3.5.可变类型

- 原始值都属于不可变类型，一旦创建就无法修改，在内存中不会创建重复的原始值
- 对象属于可变类型
  - 对象创建完成后，可以任意的添加删除修改对象中的属性
  - 注意
    - 当对两个对象进行相等或全等比较时，比较的是对象的内存地址
    - 如果有两个变量同时指向一个对象，通过一个变量修改对象时，对另外一个变量也会产生影响

- 修改对象和修改变量
  - 修改对象
    - 修改对象时，如果有其他变量指向该对象，则所有指向该对象的变量都会受到影响
  - 修改变量
    - 修改变量时，只会影响当前的变量
    - 在使用变量存储对象时，很容易因为改变变量指向的对象，提高代码的复杂度，所以通常情况下，声明存储对象的变量时会使用const
  - 注意：const只是禁止变量被重新赋值，对对象内部的修改没有任何影响

### 3.6.方法

- 方法

  - 当一个对象的属性指向一个函数，那么我们就称这个函数是该对象的方法

  - 调用函数就称为调用对象的方法

  - 函数也可以成为一个对象的属性

  - ```javascript
    obj.sayHello = function(){
        alert("hello")
    }
    ```

## 4.函数

### 4.1.函数概述

- 函数（Function）

  - 函数也是一个对象

  - 它具有其他对象所有的功能

  - 函数中可以存储代码，且可以在需要时调用这些代码

  - 语法

    - ```javascript
      function 函数名(){
      	语句...
      }
      ```

  - 调用函数

    - 调用函数就是执行函数中存储的代码

    - 语法：

      ```javascript
      函数对象()
      ```

  - 使用typeof检查函数对象时会返回function

### 4.2.函数的定义方式

- 函数的定义方式

  - 函数声明

    - ```javascript
      function 函数名(){
      	语句...
      }
      ```

  - 函数表达式

    - ```javascript
      const 变量 = function(){
      	语句...
      }
      ```

  - 箭头函数

    - ```javascript
      () => {
      	语句...
      }
      ```

    


### 4.3.函数的参数

- 参数

  - 形式参数

    - 在定义函数时，可以在函数中指定数量不等的形式参数（形参）
    - 在函数中定义形参，就相当于在函数内部声明了对应的变量但是没有赋值

  - 实际参数

    - 在调用函数时，可以在函数的()传递数量不等的实参
    - 实参会赋值给其对应的形参
    - 参数
      - 如果实参和形参数量相同，则对应的实参赋值给对应的形参
      - 如果实参多余形参，则多余的实参不会使用
      - 如果形参多余实参，则多余的形参为undefined

  - 参数的类型

    - JS中不会检查参数的类型，可以传递任何类型的值作为参数

  - 函数定义

    - 函数声明

      - ```javascript
        function 函数名([参数]){
        	语句...
        }
        ```

    - 函数表达式

      - ```javascript
        const 变量 = function([参数]){
        	语句...
        }
        ```

    - 箭头函数

      - ```javascript
        ([参数]) => {
        	语句...
        }
        ```

      - 当箭头函数中只有一个参数时，可以省略()

        ```javascript
        const fn = a => {
        	console.log("a =", a);
        }
        ```

  - 注意

    - 定义参数时，可以为参数指定默认值，默认值会在没有对应实参时生效
    - 传递实参时，传递并不是变量本身，而是变量中存储的值
    - 在JS中，函数也是一个对象（一等函数），别的对象能做的事情，函数也可以


### 4.4.函数的返回值

- 函数的返回值

  - 在函数中，可以通过return关键字来指定函数的返回值

  - 返回值就是函数的执行结果，函数调用完毕返回值便会作为结果返回

  - 任何值都可以作为返回值使用（包括对象和函数之类）

  - 如果return后不跟任何值，则相当于返回undefined;如果不写return，那么函数的返回值依然是undefined

  - return一执行函数立即结束

  - 箭头函数的返回值

    - 可以直接写在箭头后

    - 如果直接在箭头后设置对象字面量为返回值时，对象字面量必须使用()括起来

    - ```javascript
      const sum = (a, b) => a + b
      const fn = () => ({name:"孙悟空"})
      ```


### 4.5.函数的作用域

- 作用域（scope）
  - 作用域指的是一个变量的可见区域
  - 作用域有两种
    - 全局作用域
      - 全局作用域在网页运行时创建，在网页关闭时消耗
      - 所有直接编写到script标签中的代码都位于全局作用域中
      - 全局作用域中的变量是全局变量，可以在任意位置访问
    - 局部作用域
      - 块作用域
        - 块作用域是一种局部作用域
        - 块作用域在代码块执行时创建，代码块执行完毕它就销毁
        - 在块作用域中声明的变量是局部变量，只能在块内部访问，外部无法访问
      - 函数作用域
        - 函数作用域也是一种局部作用域
        - 函数作用域在函数调用时产生，调用结束后销毁
        - 函数每次调用都会产生一个全新的函数作用域
        - 在函数中定义的变量是局部变量，只能在函数内部访问，外部无法访问

- 作用域链
  - 当我们使用一个变量时，JS解释器会优先在当前作用域中寻找变量
  - 如果找到了则直接使用,如果没找到，则继续去上一层寻找，以此类推
  - 如果一直到全局作用域都没找到，则报错`xxx is not defined`

### 4.6.Window对象

- Window对象
  - 在浏览器中，浏览器为我们提供了一个window对象，可以直接访问
  - window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作
  - 除此之外window对象还负责存储JS中的内置对象和浏览器的宿主对象
  - window对象的属性可以通过window对象访问，也可以直接访问
  - 函数就可以认为是window对象的方法

### 4.7.var声明变量

- var用来声明变量
  - 作用和let相同，但是var不具有块作用域
  - 在全局中使用var声明的变量，都会作为window对象的属性保存
  - 使用function声明的函数，都会作为window的方法保存
  - 使用let声明的变量不会存储在window对象中，而存在一个秘密的小地方（无法访问）
  - var虽然没有块作用域，但有函数作用域

### 4.8.变量的提升

- 变量的提升
  - 使用var声明的变量，它会在所有代码执行前被声明，所以我们可以在变量声明前就访问变量
  - 函数的提升：使用函数声明创建的函数，会在其他代码执行前被创建，所以我们可以在函数声明前调用函数
  - let声明的变量实际也会提升，但是在赋值之前解释器禁止对该变量的访问
  - 变量和函数的提升同样适用于函数作用域

### 4.9.立即执行函数

- 立即执行函数（IIFE）

  - 在开发中应该尽量减少直接在全局作用域中编写代码，所以我们的代码要尽量编写的局部作用域， 如果使用let声明的变量，可以使用{}来创建块作用域

  - 立即是一个匿名的函数，并它只会调用一次

  - 可以利用IIFE来创建一个一次性的函数作用域，避免变量冲突的问题

  - ```javascript
    (function(){
        let a = 10
        console.log(a)
    }());
    ```


### 4.10.this

- this
  - 函数在执行时，JS解析器每次都会传递进一个隐含的参数，这个参数就叫做this
  - this会指向一个对象，所指向的对象会根据函数调用方式的不同而不同
    - 以函数形式调用时，this指向的是window
    - 以方法的形式调用时，this指向的是调用方法的对象
    - ...
  - 通过this可以在方法中引用调用方法的对象
  - 箭头函数没有自己的this，它的this有外层作用域决定，箭头函数的this和它的调用方式无关


### 4.11.箭头函数

- 箭头函数

  - ```javascript
    ([参数]) => 返回值
    ```

    - 无参箭头函数

      ```javascript
      () => 返回值
      ```

    - 一个参数的

      ```javascript
      a => 返回值
      ```

    - 多个参数的

      ```javascript
      (a, b) => 返回值
      ```

    - 只有一个语句的函数

      ```javascript
      () => 返回值
      ```

    - 只返回一个对象的函数

      ```javascript
      () => ({...})
      ```

    - 有多行语句的函数

      ```javascript
      () => {
          ...
          return 返回值
      }
      ```

  - 箭头函数没有自己的this，它的this有外层作用域决定，箭头函数的this和它的调用方式无关


### 4.12.严格模式

- JS运行代码的模式

  - 正常模式

    - 默认情况下代码都运行在正常模式中，
    - 在正常模式，语法检查并不严格，其原则是能不报错的地方尽量不报错
    - 这种处理方式导致代码的运行性能较差

  - 严格模式

    - 在严格模式下，语法检查变得严格

    - 禁止一些语法，更容易报错，提升了性能

    - 在开发中，应该尽量使用严格模式，这样可以将一些隐藏的问题消灭在萌芽阶段，时也能提升代码的运行性能

    - ```javascript
      "use strict"
      ```



## 5.面向对象

### 5.1.面向对象概述

- 面向对象编程（OOP）
  - 程序：程序就是对现实世界的抽象（照片就是对人的抽象）
  - 对象：一个事物抽象到程序中后就变成了对象，在程序的世界中，一切皆对象
  - 面向对象编程
    - 指程序中的所有操作都是通过对象来完成
    - 做任何事情之前都需要先找到它的对象，然后通过对象来完成各种操作

  - 面向对象的特点：封装、继承和多态
    - 封装 —— 安全性
    - 继承 —— 扩展性
    - 多态 —— 灵活性
  - 对象的分类
    - 内建对象
      - 由ES标准所定义的对象
      - 如 Object Function String Number ...
    - 宿主对象
      - 由浏览器提供的对象
      - BOM、DOM
    - 自定义对象
      - 由开发人员自己创建的对象

### 5.2.检查对象

- 检查对象
  - instanceof：用来检查一个对象是否是一个类的实例
    - 实例 instanceof 对象
    - instanceof检查的是对象的原型链上是否有该类实例，只要原型链上有该类实例，就会返回true
    - Object是所有对象的原型，所以任何和对象和Object进行instanceof运算都会返回true
  - in
    - "属性名" in 实例
    - 使用in运算符检查属性时，无论属性在对象自身还是在原型中，都会返回true
  - hasOwnProperty()
    - 对象.hasOwnProperty(属性名) (不推荐使用)
    - 用来检查一个对象的自身是否含有某个属性
    - Object.hasOwn(对象, 属性名) ：用来检查一个对象的自身是否含有某个属性

### 5.2.类

- 类

  - 使用Object创建对象的问题

    - 无法区分出不同类型的对象
    - 不方便批量创建对象

  - 类是对象模板，可以将对象中的属性和方法直接定义在类中，定义后，就可以直接通过类来创建对象

  - 通过同一个类创建的对象，我们称为同类对象，可以使用instanceof来检查一个对象是否是由某个类创建

  - 如果某个对象是由某个类所创建，则我们称该对象是这个类的实例

  - 语法

    - ```javascript
      class 类名 {} 		// 类名要使用大驼峰命名
      const 类名 = class {} 
      ```

    - 调用构造函数创建对象实例

      - ```javascript
        new 类()
        ```

### 5.3.类的属性

- 属性
  - 类的代码块，默认就是严格模式，类的代码块是用来设置对象的属性的，不是什么代码都能写
  - 实例属性只能通过实例访问：p1.age
  - 使用static声明的属性，是静态属性（类属性）
  - 静态属性只能通过类去访问Person.test

### 5.4.类的方法

- 方法

  - ```javascript
    sayHello = function(){
    	...
    }
    ```

  - ```javascript
    sayHello(){
    	...
    }
    ```

  - 实例方法中this就是当前实例

  - 静态方法（类方法）通过类来调用，静态方法中this指向的是当前类Person.f()

### 5.5.构造函数

- 构造函数

  - 在类中可以添加一个特殊的方法constructor，该方法我们称为构造函数（构造方法），构造函数会在我们调用类创建对象时执行

  - ```javascript
    constructor([参数]){
        ...
    }
    ```

  - 可以在构造函数中，为实例属性进行赋值

  - 在构造函数中，this表示当前所创建的对象



### 5.6.封装

- 封装

  - 对象就是一个用来存储不同属性的容器，对象不仅存储属性，还要负责数据的安全，直接添加到对象中的属性，并不安全，因为它们可以被任意的修改

  - 确保数据的安全

    - 私有化数据：将需要保护的数据设置为私有，只能在类内部使用
    - 提供setter和getter方法来开放对数据的操作
      - 可以控制属性的读写权限
      - 可以在方法中对属性的值进行验证

  - 封装主要用来保证数据的安全

  - 实现封装的方式

    - 属性私有化：加#，#属性

    - 通过getter和setter方法来操作属性

      - ```javascript
        get 属性名(){
        	return this.#属性
        }
        
        set 属性名(参数){
        	this.#属性 = 参数
        }
        ```

### 5.7.多态

- 多态
  - 在JS中不会检查参数的类型，所以这就意味着任何数据都可以作为参数传递
  - 要调用某个函数，无需指定的类型，只要对象满足某些条件即可

### 5.8.继承

- 继承

  - 可以通过extends关键来完成继承
  - 当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类中（简单理解）
  - 继承发生时，被继承的类称为 父类（超类），继承的类称为子类
  - 通过继承可以减少重复的代码，并且可以在不修改一个类的前提对其进行扩展
  - 通过继承可以在不修改一个类的情况下对其进行扩展
    - OCP：开闭原则，程序应该对修改关闭，对扩展开放
    - 重写：在子类中，可以通过创建同名方法来重写父类的方法
      - 重写构造函数时，构造函数的第一行代码必须为super()
      - 在方法中可以使用super.方法()来引用父类的方法

  

### 5.9.对象的结构

- 对象中存储属性的区域实际有两个
  - 对象自身
    - 直接通过对象所添加的属性，位于对象自身中
    - 在类中通过 x = y 的形式添加的属性，位于对象自身中
  - 原型对象（prototype）
    - 对象中还有一些内容，会存储到其他的对象里（原型对象）
    - 在对象中会有一个属性用来存储原型对象，这个属性叫做__proto__
    - 原型对象也负责为对象存储属性，当我们访问对象中的属性时，会优先访问对象自身的属性，对象自身不包含该属性时，才会去原型对象中寻找
    - 会添加到原型对象中的情况
      - 在类中通过xxx(){}方式添加的方法，位于原型中
      - 主动向原型中添加的属性或方法

### 5.10.原型对象

- 访问一个对象的原型对象
  - 对象.__proto__
  - Object.getPrototypeOf(对象)

- 原型对象中的数据
  - 对象中的数据（属性、方法等）
  - constructor （对象的构造函数）

- 原型的作用

  - 原型就相当于是一个公共的区域，可以被所有该类实例访问
  - 可以将该类实例中，所有的公共属性（方法）统一存储到原型中
  - 这样我们只需要创建一个属性，即可被所有实例访问
  - JS中继承就是通过原型来实现的
    - 当继承时，子类的原型就是一个父类的实例
    - 在对象中有些值是对象独有的，像属性每个对象都应该有自己值，但是有些值对于每个对象来说都是一样的，像各种方法，对于一样的值没必要重复的创建

- 修改原型
  - 大部分情况下，我们是不需要修改原型对象
  - 注意：千万不要通过类的实例去修改原型
  - 修改原型
    - 处理通过__proto__能访问对象的原型外，还可以通过类的prototype属性，来访问实例的原型，修改原型时，最好通过通过类去修改
      - 一修改就是修改所有实例的原型
      - 无需创建实例即可完成对类的修改
  - 原则
    - 原型尽量不要手动改
    - 要改也不要通过实例对象去改
    - 通过 类.prototype 属性去修改
    - 最好不要直接给prototype去赋值


### 5.11.原型链

- 原型链
  - 读取对象属性时，会优先对象自身属性

  - 如果对象中有，则使用，没有则去对象的原型中寻找

  - 如果原型中有，则使用，没有则去原型的原型中寻找

  - 直到找到Object对象的原型（Object的原型没有原型）

  - 注意
    - 原型对象也有原型，这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同
    - 所有的同类型对象它们的原型对象都是同一个，也就意味着，同类型对象的原型链是一样的
    - 作用域链，是找变量的链，找不到会报错
    - 原型链，是找属性的链，找不到会返回undefined

### 5.12.垃圾回收

- 垃圾回收（Garbage collection）
  - 在JS中有自动的垃圾回收机制，这些垃圾对象会被解释器自动回收，我们无需手动处理
  - 对于垃圾回收来说，唯一能做的事情就是将不再使用的变量设置为null



## 6.数组

### 6.1.数组概述

- 数组（Array）

  - 数组也是一种复合数据类型，在数组可以存储多个不同类型的数据
    - 数组中存储的是有序的数据，数组中的每个数据都有一个唯一的索引，可以通过索引来操作获取数据
    - 数组中存储的数据叫做元素
    - 索引（index）是一组大于0的整数
  - 创建数组：通过Array()来创建数组，也可以通过[]来创建数组
  - 向数组中添加元素：数组[索引] = 元素
  - 读取数组中的元素：组[索引]
    - 如果读取了一个不存在的元素，不好报错而是返回undefined
  - length
    - 获取数组的长度
    - 获取的实际值就是数组的最大索引 + 1
    - 向数组最后添加元素：数组[数组.length] = 元素
    - length是可以修改的

- 遍历数组

  - for循环

    - ```javascript
      for(let i=0; i<arr.length; i++){
      	console.log(arr[i])
      }
      ```

  - for-of语句

    - ```javascript
      for(变量 of 可迭代的对象){
      	语句...
      }
      ```

    - for-of的循环体会执行多次，数组中有几个元素就会执行几次，每次执行时都会将一个元素赋值给变量


### 6.2.数组的方法

- Array.isArray()
  - Array.isArray(数组)
  - 用来检查一个对象是否是数组
- 数组.at()
  - 数组.at(数值)
  - 可以根据索引获取数组中的指定元素
  - at可以接收负索引作为参数，倒数第几个
- concat()
  - 新数组=数组.concat([连接数组])
  - 用来连接两个或多个数组
  - 非破坏性方法，不会影响原数组，而是返回一个新的数组
- 数组.indexOf()
  - 获取元素在数组中第一次出现的索引
  - 参数
    - 要查询的元素
    - 查询的起始位置
- 数组.lastIndexOf()
  - 获取元素在数组中最后一次出现的位置
  - 返回值
    - 找到了则返回元素的索引
    - 没有找到返回-1
- 数组.join()
  - 将一个数组中的元素连接为一个字符串（默认逗号隔开）
  - 参数：指定一个字符串作为连接符
- 数组.slice()
  - 用来截取数组（非破坏性方法）
  - 参数
    - 截取的起始位置（包括该位置）
    - 截取的结束位置（不包括该位置）
      - 第二个参数可以省略不写，如果省略则会一直截取到最后
  - 索引可以是负值
  - 如果将两个参数全都省略，则可以对数组进行浅拷贝（浅复制）

- 数组.push()
  - 向数组的末尾添加一个或多个元素，并返回新的长度
- 数组.pop()
  - 删除并返回数组的最后一个元素
- 数组.unshift()
  - 向数组的开头添加一个或多个元素，并返回新的长度
- 数组.shift()
  - 删除并返回数组的第一个元素
- 数组.splice()
  - 可以删除、插入、替换数组中的元素
  - 参数
    - 删除的起始位置
    - 删除的数量
    - 要插入的元素（插入到删除的起始位置前）
  - 返回值
    - 返回被删除的元素
- 数组.reverse()
  - 反转数组

- 数组.sort()
  - sort用来对数组进行排序（会对改变原数组）
  - sort默认会将数组升序排列
  - 注意：sort默认会按照Unicode编码进行排序，所以如果直接通过sort对数字进行排序，能会得到一个不正确的结果
  - 参数
    - 可以传递一个回调函数作为参数，通过回调函数来指定排序规则
    - (a, b) => a - b 升序排列
    - (a, b) => b - a 降序排列
- 数组.forEach()
  - 用来遍历数组
  - 它需要一个回调函数作为参数，这个回调函数会被调用多次
  - 数组中有几个元素，回调函数就会调用几次，每次调用，都会将数组中的数据作为参数传递
  - 回调函数中有三个参数
    - element 当前的元素
    - index 当前元素的索引 
    - array 被遍历的数组
- 数组.filter()
  - 将数组中符合条件的元素保存到一个新数组中返回
  - 需要一个回调函数作为参数，会为每一个元素去调用回调函数，并根据返回值来决定是否将元素添加到新数组中
  - 非破坏性方法，不会影响原数组
  - 回调函数中有三个参数
    - element 当前的元素
    - index 当前元素的索引
    - array 被遍历的数
- 数组.map()
  - 根据当前数组生成一个新数组
  - 需要一个回调函数作为参数，回调函数的返回值会成为新数组中的元素
  - 非破坏性方法不会影响原数组
  - 回调函数中有三个参数
    - element 当前的元素
    - index 当前元素的索引
    - array 被遍历的数
- 数组.reduce()
  - 可以用来将一个数组中的所有元素整合为一个值
  - 参数
    - 回调函数，通过回调函数来指定合并的规则
    - 可选参数，添加了初始值当作了回调函数的第一个参数


### 6.3.复制

- 复制（Copy）
  - 复制分类
    - 浅拷贝（shallow copy）
      - 通常对对象的拷贝都是浅拷贝
      - 浅拷贝顾名思义，只对对象的浅层进行复制（只复制一层）
      - 如果对象中存储的数据是原始值，那么拷贝的深浅是不重要
      - 浅拷贝只会对对象本身进行复制，不会复制对象中的属性（或元素）
    - 深拷贝（deep copy）
      - 深拷贝指不仅复制对象本身，还复制对象中的属性和元素
      - 因为性能问题，通常情况不太使用深拷贝
  - 对象的复制
    - 数组复制
      - 新数组=旧数组.slice()
        - 当调用slice时，会产生一个新的数组对象，从而完成对数组的复制
        - 浅复制
      - ... (展开运算符)
        - 可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递
        - 通过它也可以对数组进行浅复制
    - 对象的复制
      - Object.assign(目标对象, 被复制的对象)
      - 将被复制对象中的属性复制到目标对象里，并将目标对象返回，也可以使用展开运算符对对象进行复制

### 6.4.高阶函数

- 回调函数（callback）：一个函数的参数也可以是函数，如果将函数作为参数传递，那么我们就称这个函数为回调函数

- 高阶函数

  - 如果一个函数的参数或返回值是函数，则这个函数就称为高阶函数

  - 将函数作为参数，意味着可以对另一个函数动态的传递代码

  - 通常回调函数都是匿名函数

    - ```javascript
      function outer(cb){
          return () => {
              console.log("记录日志~")
              const result = cb()
              return result
          }
      }
      function test(){
          console.log("test~")
          return "test"
      }
      outer(test)
      ```

### 6.5.闭包

- 闭包

  - 闭包就是能访问到外部函数作用域中变量的函数，当我们需要隐藏一些不希望被别人访问的内容时就可以使用闭包

  - 构成闭包的要件

    - 函数的嵌套
    - 内部函数要引用外部函数中的变量
    - 内部函数要作为返回值返回

  - ```javascript
    function outer(){
        let num = 0 // 位于函数作用域中
        return () => {
            num++
            console.log(num)
        }
    }
    const newFn = outer()
    ```

  - 函数在作用域，在函数创建时就已经确定的（词法作用域），和调用的位置无关，闭包利用的就是词法作用域

  - 闭包的生命周期

    - 闭包在外部函数调用时产生，外部函数每次调用都会产生一个全新的闭包
    - 在内部函数丢失时销毁（内部函数被垃圾回收了，闭包才会消失）

  - 注意事项

    - 闭包主要用来隐藏一些不希望被外部访问的内容，这就意味着闭包需要占用一定的内存空间
    - 相较于类来说，闭包比较浪费内存空间（类可以使用原型而闭包不能）
    - 需要执行次数较少时，使用闭包
    - 需要大量创建实例时，使用类

### 6.6.可变参数

- arguments
  - arguments是函数中又一个隐含参数
  - arguments是一个类数组对象（伪数组），和数组相似，可以通过索引来读取元素，也可以通过for循环变量，但是它不是一个数组对象，不能调用数组的方法
  - rguments用来存储函数的实参，无论用户是否定义形参，实参都会存储到arguments对象中，可以通过该对象直接访问实参
- 可变参数
  - ...参数名
  - 在定义函数时可以将参数指定为可变参数
  - 可变参数可以接收任意数量实参，并将他们统一存储到一个数组中返回
  - 可变参数的作用和arguments基本是一致，但是也具有一些不同点
    - 可变参数的名字可以自己指定
    - 可变参数就是一个数组，可以直接使用数组的方法
    - 可变参数可以配合其他参数一起使用

### 6.7.调用函数

- 根据函数调用方式的不同，this的值也不同
  - 以函数形式调用，this是window
  - 以方法形式调用，this是调用方法的对象
  - 构造函数中，this是新建的对象
  - 箭头函数没有自己的this，由外层作用域决定
  - 通过call和apply调用的函数，它们指定第一个参数就是函数的this

- 调用函数
  - 调用函数除了通过 函数() 这种形式外，还可以通过其他的方式来调用函数
  - 函数.call()/函数.apply()
    - call 和 apply除了可以调用函数，还可以用来指定函数中的this
    - call和apply的第一个参数，将会成为函数的this
    - 通过call方法调用函数，函数的剩余实参直接在第一个参数后一个一个的列出来
    - 通过apply方法调用函数，函数的剩余实参需要通过一个数组传递

- bind函数
  - 函数.bind()是函数的方法，可以用来创建一个新的函数
  - bind可以为新函数绑定this（第一个参数），并且锁死，继续调用无法修改
  - bind可以为新函数绑定参数，同样锁死
- 箭头函数的调用
  - 箭头函数没有自身的this，它的this由外层作用域决定
  - 箭头函数无法通过call，apply 和 bind修改它的this
  - 箭头函数中没有arguments



## 7.内建对象

### 7.1.结构赋值

- 数组的结构赋值
  - [变量,变量,变量]=数组
  - [变量,变量,...变量]=数组解构数组时，可以使用...来设置获取多余的元素
  - 可以通过解构赋值来快速交换两个变量的值
    - [a1,a2]=[a2,a1]
- 对象的结构赋值
  - {name,age,gender} = obj
  - {address} = obj：没有的属性返回undefined
  - {name:a, age:b, gender:c, address:d="花果山"} = obj：为属性变量重命名，也可赋值

### 7.2.对象的序列化

- 对象的序列化

  - 序列化指将对象转换为一个可以存储的格式
  - 在JS中对象的序列化通常是将一个对象转换为字符串（JSON字符串）
  - 序列化的用途
    - 对象转换为字符串后，可以将字符串在不同的语言之间进行传递，甚至人可以直接对字符串进行读写操作，使得JS对象可以不同的语言之间传递
    - 用途
      - 作为数据交换的格式
      - 用来编写配置文件
  - 序列化
    - 在JS中有一个工具类 JSON （JavaScript Object Notation） JS对象表示法
    - JS对象序列化后会转换为一个字符串，这个字符串我们称其为JSON字符串
    - 也可以手动的编写JSON字符串，在很多程序的配置文件就是使用JSON编写的
    - JSON.stringify(对象)：可以将一个对象转换为JSON字符串
    - JSON.parse(字符串)：可以将一个JSON格式的字符串转换为JS对象
  - 编写JSON的注意事项
    - JSON字符串有两种类型
      - JSON对象 {}
      - JSON数组 []
    - JSON字符串的属性名必须使用双引号引起来
    - JSON中可以使用的属性值（元素）
      - 数字（Number）
      - 字符串（String） 必须使用双引号
      - 布尔值（Boolean）
      - 空值（Null）
      - 对象（Object {}）
      - 数组（Array []）
    - JSON的格式和JS对象的格式基本上一致的
    - 注意：JSON字符串如果属性是最后一个，则末尾不要再加逗号

- 深复制

  - 对obj进行浅复制

    - const newObj = Object.assign({}, obj)

  - 对obj进行深复制

    - const newObj = structuredClone(obj)

    - 利用JSON来完成深复制

      - ```javascript
        const str = JSON.stringify(obj)
        const newObj = JSON.parse(str)
        
        const newObj = JSON.parse(JSON.stringify(obj))
        ```

### 7.3.Map

- Map

  - Map用来存储键值对结构的数据（key-value）
  - Object中存储的数据就可以认为是一种键值对结构
  - Map和Object的主要区别
    - Object中的属性名只能是字符串或符号，如果传递了一个其他类型的属性名，JS解释器会自动将其转换为字符串
    - Map中任何类型的值都可以称为数据的key
  - 创建：new Map()
  - 属性和方法
    - map.size() 获取map中键值对的数量
    - map.set(key, value) 向map中添加键值对
    - map.get(key) 根据key获取值
    - map.delete(key) 删除指定数据
    - map.has(key) 检查map中是否包含指定键
    - map.clear() 删除全部的键值对
    - map.keys() - 获取map的所有的key
    - map.values() - 获取map的所有的value

- 将map转换为数组

  - ```javascript
    const arr = Array.from(map)
    
    const arr = [...map]
    ```

###  7.4.Set

- Set

  - Set用来创建一个集合

  - 它的功能和数组类似，不同点在于Set中不能存储重复的数据

  - 使用方式

    - 创建
      - new Set()
      - new Set([...])
    - 方法
      - size 获取数量
      - add() 添加元素
      - has() 检查元素
      - delete() 删除元素

  - 给数组去重

    - ```javascript
      const set = new Set(arr)
      const newArr=[...set]
      ```

### 7.5.Math

- Math
  - Math一个工具类
  - Math中为我们提供了数学运算相关的一些常量和方法
  - 常量
    - Math.PI 圆周率
  - 方法
    - Math.abs() 求一个数的绝对值
    - Math.min() 求多个值中的最小值
    - Math.max() 求多个值中的最大值
    - Math.pow() 求x的y次幂
    - Math.sqrt() 求一个数的平方根
    - Math.floor() 向下取整
    - Math.ceil() 向上取整
    - Math.round() 四舍五入取整
    - Math.trunc() 直接去除小数位
    - Math.random() 生成一个0-1之间的随机数，(0,1]

### 7.6.Date

- Date

  - 在JS中所有的和时间相关的数据都由Date对象来表示
  - 对象的方法
    - getFullYear() 获取4位年份
    - getMonth() 返当前日期的月份（0-11）
    - getDate() 返回当前是几日
    - getDay() 返回当前日期是周几（0-6） 0表示周日
    - getTime() 返回当前日期对象的时间戳
      - 时间戳：自1970年1月1日0时0分0秒到当前时间所经历的毫秒数
      - 计算机底层存储时间时，使用都是时间戳
      - Date.now() 获取当前的时间戳

- 日期的格式化

  - toLocaleString()

    - 可以将一个日期转换为本地时间格式的字符串

    - 参数

      - 描述语言和国家信息的字符串

        - zh-CN 中文中国
        - zh-HK 中文香港
        - en-US 英文美国

      - 需要一个对象作为参数，在对象中可以通过对象的属性来对日期的格式进行配置

        - ```javascript
          dateStyle 日期的风格
          timeStyle 时间的风格
              full
              long
              medium
              short
          hour12 是否采用12小时值
              true
              false
          weekday 星期的显示方式
              long
              short
              narrow
          
          year
              numeric
              2-digit
          ```



### 7.7.包装类

- 包装类

  - 在JS中，除了直接创建原始值外，也可以创建原始值的对象

    - 通过 new String() 可以创建String类型的对象
    - 通过 new Number() 可以创建Number类型的对象
    - 通过 new Boolean() 可以创建Boolean类型的对象

  - 包装类

    - JS中一共有5个包装类

      - ```javascript
        String --> 字符串包装为String对象
        Number --> 数值包装为Number对象
        Boolean --> 布尔值包装为Boolean对象
        BigInt --> 大整数包装为BigInt对象
        Symbol --> 符号包装为Symbol对象
        ```

      - 通过包装类可以将一个原始值包装为一个对象，当我们对一个原始值调用方法或属性时，JS解释器会临时将原始值包装为对应的对象，然后调用这个对象的属性或方法

      - 由于原始值会被临时转换为对应的对象，这就意味着对象中的方法都可以直接通过原始值来调用

### 7.8.字符串

- 字符串
  - 字符串其本质就是一个字符数组
  - "hello" --> ["h", "e", "l", "l", "o"]
  - 字符串的很多方法都和数组是非常类似的
  - 属性和方法
    - str.length 获取字符串的长度
    - 字符串[索引] 获取指定位置的字符
    - str.at() （实验方法）：根据索引获取字符，可以接受负索引
    - str.charAt()：根据索引获取字符
    - str.concat()：用来连接两个或多个字符串
    - str.includes()：用来检查字符串中是否包含某个内容，有返回true，没有返回false
    - str.indexOf()/str.lastIndexOf()：查询字符串中是否包含某个内容，返回前/后位置
    - str.startsWith()：检查一个字符串是否以指定内容开头
    - str.endsWith()：检查一个字符串是否以指定内容结尾
    - str.padStart()/str.padEnd()：通过添加指定的内容，使字符串保持某个长度
    - str.replace()：使用一个新字符串替换一个指定内容
    - str.replaceAll()：使用一个新字符串替换所有指定内
    - str.slice()：对字符串进行切片
    - str.substring()：截取字符串
    - str.split()：用来将一个字符串拆分为一个数组
    - str.toLowerCase()：将字符串转换为小写
    - str.toUpperCase()：将字符串转换为大写
    - str.trim()：去除前后空格
    - str.trimStart()：去除开始空格
    - str.trimEnd()：去除结束空格
    - str.split()：可以根据正则表达式来对一个字符串进行拆分
    - str.search()：可以去搜索符合正则表达式的内容第一次在字符串中出现的位置
    - str.replace()：根据正则表达式替换字符串中的指定内容
    - str.match()：根据正则表达式去匹配字符串中符合要求的内容
    - str.matchAll()
      - 根据正则表达式去匹配字符串中符合要求的内容(必须设置g 全局匹配)
      - 它返回的是一个迭代器

### 7.9.正则表达式

- 正则表达式

  - 正则表达式用来定义一个规则

  - 通过这个规则计算机可以检查一个字符串是否符合规则，或者将字符串中符合规则的内容提取出来

  - 正则表达式也是JS中的一个对象，所以要使用正则表达式，需要先创建正则表达式的对象

  - 正则表达式创建

    - new RegExp("正则表达式","匹配模式")

      - ```javascript
        reg = new RegExp("a", "i") // 通过构造函数来创建一个正则表达式的对象
        ```

    - /正则/匹配模式

      - 使用字面量来创建正则表达式

      - ```javascript
        reg = /a/i
        reg = /\w/
        ```

  - test()

    - 通过正则表达式检查一个字符串是否符合规则
    - reg.test(str)   


- [匹配模式](https://www.runoob.com/regexp/regexp-syntax.html)


## 8.DOM

### 8.1.DOM概述

- DOM（Document Object Model）
  - Document Object Model，文档对象模型
    - D：Document，即文档；指整个网页，DOM是用来操作网页的
    - O：Object，即对象；DOM将网页中的每一部分内容都转换为对象，以面向对象的方式去操作网页
    - M：Model，即模型；模型用来表示对象之间的关系（父子元素、祖先后代、兄弟元素等），明确关系后，通过任意一个对象去获取其他的对象
  - DOM属于Web API的一部分，Web API中定义了非常多的对象，通过这些对象可以完成对网页的各种操作（添加删除元素、发送请求、操作浏览器等）
- 节点（Node）
  - 节点：在DOM标准下，网页中的每一个部分都会转换为对象，统称为节点
  - 节点类型
    - 文档节点
    - 元素节点
    - 文本节点
    - 属性节点
    - …
- 关系
  - 祖先 ：包含后代元素的元素是祖先元素
  - 后代 ：被祖先元素包含的元素是后代元素
  - 父 ：直接包含子元素的元素是父元素
  - 子 ：直接被父元素包含的元素是子元素
  - 兄弟 ：拥有相同父元素的元素是兄弟元素

### 8.2.DOM的使用

- DOM的使用

  - 要使用DOM来操作网页，我们需要浏览器至少得先给我一个对象，才能去完成各种操作

  - 浏览器提供了一个document对象，它是一个全局变量可以直接使用

  - document代表的是整个的网页

  - ```html
    <body>
    	<button id="btn"></button>
        <script>
            // 获取btn对象
            const btn = document.getElementById("btn")
            // 修改btn中的文字
            btn.innerText = "Click ME"
        </script>
    </body>
    ```

### 8.3.document对象

- document对象

  - document对象表示的是整个网页

  - document对象的原型链

    - `HTMLDocument -> Document -> Node -> EventTarget -> Object.prototype -> null`
    - 凡是在原型链上存在的对象的属性和方法都可以通过Document去调用

  - 部分属性

    - ```javascript
      // 获取网页中的元素
      document.documentElement --> html根元素
      document.body --> body元素
      document.head --> head元素
      document.title --> title元素
      document.links --> a元素
      ...
      ```

### 8.4.获取元素节点

- 元素节点对象（element）
  - 在网页中，每一个标签都是一个元素节点
  - 元素节点的操作
    - 通过document对象来获取元素节点
    - 通过document对象来创建元素节点
- 通过document来获取已有的元素节点
  - document.getElementById()
    - 根据id获取一个元素节点对象
  - document.getElementsByClassName()
    - 根据元素的class属性值获取一组元素节点对象
    - 返回的是一个类数组对象
    - 该方法返回的结果是一个实时更新的集合,当网页中新添加元素时，集合也会实时的刷新
  - document.getElementsByTagName()
    - 根据标签名获取一组元素节点对象
    - 返回的结果是可以实时更新的集合
    - document.getElementsByTagName("*")：获取页面中所有的元素
  - document.getElementsByName()
    - 根据name属性获取一组元素节点对象
    - 返回一个实时更新的集合
    - 主要用于表单项
  - document.querySelectorAll()
    - 根据选择器去页面中查询元素（选择器：`div`，``#btn`，`.box`，`[name=username]`）
    - 会返回一个类数组（不会实时更新）
  - document.querySelector()
    - 根据选择器去页面中查询第一个符合条件的元素
- 通过document对象来创建元素节点
  - document.createElement()
    - 根据标签名创建一个元素节点对象

- div元素的原型链
  - `HTMLDivElement -> HTMLElement -> Element -> Node -> ...`
- 通过元素节点对象获取其他节点的方法
  - element.getElementById()：功能和document.getElementById()，但范围在element内
  - element.childNodes：获取当前元素的子节点（会包含空白的子节点）
  - element.children：获取当前元素的子元素
  - element.firstElementChild：获取当前元素的第一个子元素
  - element.lastElementChild：获取当前元素的最后一个子元素
  - element.nextElementSibling：获取当前元素的下一个兄弟元素
  - element.previousElementSibling：获取当前元素的前一个兄弟元素
  - element.parentNode：获取当前元素的父节点
  - element.tagName：获取当前元素的标签名

### 8.5.文本节点

- 文本节点对象

  - 在DOM中，网页中所有的文本内容都是文本节点对象
  - 可以通过元素来获取其中的文本节点对象，但是我们通常不会这么做
  - 可以直接通过元素去修改其中的文本
- 修改文本的属性
  - element.textContent
    - 获取或修改元素中的文本内容
    - 获取的是标签中的内容，不会考虑css样式
    - 当字符串中有标签时，会自动对标签进行转义（\<li> --> \&lt;li\&gt;）
  - element.innerText
    - 获取或修改元素中的文本内容
    - innerText获取内容时，会考虑css样式
    - 通过innerText去读取CSS样式，会触发网页的重排（计算CSS样式）
    - 当字符串中有标签时，会自动对标签进行转义（\<li> --> \&lt;li\&gt;）
  - element.innerHTML 
    - 获取或修改元素中的html代码
    - 可以直接向元素中添加html代码
    - innerHTML插入内容时，有被xss注入的风险

### 8.6.属性节点

- 属性节点（Attr）
  - 在DOM也是一个对象，通常不需要获取对象而是直接通过元素即可完成对其的各种操作
  - 操作属性节点
    - 方法一
      - 读取：元素.属性名
        - 注意，class属性需要使用className来读取
        - 读取一个布尔值（无属性值的属性，如disabled），会返回true或false
      - 修改：元素.属性名 = 属性值
    - 方法二
      - 读取：元素.getAttribute(属性名)
      - 修改：元素.setAttribute(属性名, 属性值)
      - 删除：元素.removeAttribute(属性名)

### 8.7.事件

- 事件（event）

  - 事件就是用户和页面之间发生的交互行为，如：点击按钮、鼠标移动、双击按钮、敲击键盘、松开按键... 

  - 可以通过为事件绑定响应函数（回调函数），来完成和用户之间的交互

  - 绑定响应函数的方式

    - 可以直接在元素的属性中设置

      - ```html
        <button id="btn" onclick="alert('你点我干嘛~')">点我一下</button>
        ```

    - 可以通过为元素的指定属性设置回调函数的形式来绑定事件（一个事件只能绑定一个响应函数）

      - ```javascript
        // 获取到按钮对象
        const btn = document.getElementById("btn")
        // 为按钮对象的事件属性设置响应函数
        btn.onclick = function(){
        	alert("我又被点了一下~~")
        }
        ```

      - 不能重复绑定

    - 可以通过元素addEventListener()方法来绑定事件

      - ```javascript
        btn.addEventListener("click", function(){
            alert("不要点我了~~~")
        })
        ```

      - 可以重复绑定，触发后先后依次执行

### 8.8.文档的加载

- 文档的加载

  - 网页是自上向下加载的，如果将js代码编写到网页的上边，js代码在执行时，网页还没有加载完毕，这时会出现无法获取到DOM对象的情况

  - 解决方案

    - 将script标签编写到body的最后

    - 将代码编写到window.onload的回调函数中

      - window.onload事件会在窗口中的内容加载完毕之后才触发

      - ```javascript
        window.onload = function () {
            const btn = document.getElementById("btn")
            alrert(btn)
        }
        ```

    - 将代码编写到document对象的DOMContentLoaded的回调函数中

      - document的DOMContentLoaded事件会在当前文档加载完毕之后触发

      - ```javascript
        document.addEventListener("DOMContentLoaded", function () {
            const btn = document.getElementById("btn")
            alert(btn)
        })
        ```

    - 将代码编写到外部的js文件中，然后以defer的形式进行引入DOMContentLoaded）

      - ```javascript
        // script.js
        const btn = document.getElementById("btn")
        alert(btn)
        
        <script defer src="./script.js"></script>
        ```

    - 执行时机（早-晚）：body最后>外部defer引入>DOMContentLoaded>window.onload

### 8.9.元素的操作-标签

- 添加节点

  - 获取元素

  - 创建新节点

  - 插入节点

    - appendChild()

      - 用于给一个节点添加子节点

      - ```javascript
        元素.appendChild(新节点)
        ```

    - insertAdjacentElement()

      - 可以向元素的任意位置添加元素

      - 参数

        - 添加的位置
          - beforeend：标签的最后
          - afterbegin：标签的开始
          - beforebegin：在元素的前边插入元素（兄弟元素）
          - afterend：在元素的后边插入元素（兄弟元素）
        - 添加的元素

      - ```javascript
        元素.insertAdjacentElement("位置", 新节点)
        ```

    - insertAdjacentHTML()

      - ```javascript
        元素.insertAdjacentHTML("位置", "HTML代码")
        ```

- 替换节点

  - replaceWith()

    - 使用一个元素替换当前元素

    - ```javascript
      元素.replaceWith(新节点)
      ```

- 删除节点

  - remove()

    - 删除当前元素

    - ```javascript
      元素.remove()
      ```

- 节点的复制

  - cloneNode()：对节点进行复制
  - cloneNode()复制节点时，会复制节点的所有特点，包括各种属性
    - 有id的节点，需要为复制所得节点设置新id
  - cloneNode()默认只复制当前节点，而不复制节点的子节点
    - cloneNode(true)，这样该方法也会将元素的子节点一起复制

### 8.10.样式的操作-CSS

- 修改CSS样式
  - 方法一
    - 元素.style.样式名=样式值
    - 样式名含有-，需将样式名改为驼峰命名法，如background-color --> backgroundColor
  - 方法二
    - 除了直接修改样式外，也可以通过修改class属性来间接的修改样式
    - 通过class修改样式
      - 可以一次性修改多个样式
      - 对JS和CSS进行解耦
    - 元素.classList
      - 对象，对象中提供了对当前元素的类的各种操作方法
      - 元素.classList.add(样式名...)：向元素中添加一个或多个class
      - 元素.classList.remove(样式名...)：移除元素中的一个或多个class
      - 元素.classList.toggle(样式名)：切换元素中的class
      - 元素.classList.replace(旧样式名,新样式名)：替换class
      - 元素.classList.contains(样式名)：检查class
- 读取CSS样式
  - 方法一
    - getComputedStyle(要获取样式的对象,要获取的伪元素)
    - 返回一个对象，这个对象中包含了当前元素所有的生效的样式
    - 参数
      - 要获取样式的对象
      - 要获取的伪元素（可选）
    - 返回值：返回的一个对象，对象中存储了当前元素的样式
    - 注意：样式对象中返回的样式值不一定能来拿来直接计算，要确保值是可以计算的
  - 方法二
    - 元素.对应属性
    - 元素.clientHeight/元素.clientWidth
      - 获取元素内部的宽度和高度（包括内容区和内边距）
    - 元素.offsetHeight/元素.offsetWidth
      - 获取元素的可见框的大小（包括内容区、内边距和边框）
    - 元素.offsetParent
      - 获取元素的定位父元素
      - 定位父元素：离当前元素最近的开启了定位的祖先元素，如果所有的元素都没有开启定位则返回body
    - 元素.offsetTop/元素.offsetLeft
      - 获取元素相对于其定位父元素的偏移量
    - 元素.scrollHeight/元素.scrollWidth
      - 获取元素滚动区域的大小
    - 元素.scrollTop/元素.scrollLeft
      - 获取或设置元素滚动条的偏移量

### 8.11.事件对象

- 事件对象

  - 事件对象是由浏览器在事件触发时所创建的对象，这个对象中封装了事件相关的各种信息
  - 通过事件对象可以获取到事件的详细信息，比如：鼠标的坐标、键盘的按键...
  - 浏览器在创建事件对象后，会将事件对象作为响应函数的参数传递，所以我们可以在事件的回调函数中定义一个形参来接收事件对象

### 8.12.Event对象

- Event对象
  - 在DOM中存在着多种不同类型的事件对象，多种事件对象有一个共同的祖先Event
    - event.x/event.y：鼠标的坐标
    - event.target：表示触发事件的对象
    - event.currentTarget：表示绑定事件的对象（同this）
    - event.stopPropagation()：停止事件的传导
    - event.preventDefault()：取消默认行为（如超链接的跳转）

### 8.13.事件的冒泡

- 事件的冒泡（bubble）

  - 事件的冒泡就是指事件的向上传到

  - 当元素上的某个事件被触发后，其祖先元素上的相同事件也会同时被触发

  - 冒泡简化了代码的编写，但是有时并不希望冒泡存在，可以通过事件对象来取消冒泡

  - 事件的冒泡和元素的样式无关，只和结构相关



### 8.14.事件的委派

- 事件的委派：将本该绑定给多个元素的事件，统一绑定给document，这样可以降低代码复杂度方便维护

  

### 8.15.事件的捕获

- 事件的传播机制
  - 在DOM中，事件的传播可以分为三个阶段
    - 捕获阶段 （由祖先元素向目标元素进行事件的捕获；默认情况下，事件不会在捕获阶段触发）
    - 目标阶段 （触发事件的对象）
    - 冒泡阶段 （由目标元素向祖先元素进行事件的冒泡）
- 事件的捕获：指事件从外向内的传导，当前元素触发事件以后，会先从当前元素最大的祖先元素开始向当前元素进行事件的捕获
  - 如果希望在捕获阶段触发事件，可以将addEventListener的第三个参数设置为true
  - 一般情况下我们不希望事件在捕获阶段触发，通常都不需要设置第三个参数
  - event.eventPhase：eventPhase 表示事件触发的阶段（1-捕获阶段，2-目标阶段，3-冒泡阶段）

### 8.16.定时器

- 定时器
  - 通过定时器，可以使代码在指定时间后执行
  - 设置定时器的方式有两种
    - setTimeout()
      - 参数
        - 回调函数（要执行的代码）
        - 间隔的时间（毫秒）
      - 关闭定时器：clearTimeout()
    - setInterval()：每间隔一段时间代码就会执行一次
      - 参数
        - 回调函数（要执行的代码）
        - 间隔的时间（毫秒）
      - 关闭定时器：clearInterval()
  - 定时器的本质，就是在指定时间后将函数添加到消息队列中



### 8.17.事件循环

- 事件循环（event loop）
  - 函数在每次执行时，都会产生一个执行环境
  - 执行环境负责存储函数执行时产生的一切数据
  - 函数的执行环境存储到调用栈
- 调用栈（call stack）
  - 调用栈负责存储函数的执行环境
  - 当一个函数被调用时，它的执行环境会作为一个栈帧，插入到调用栈的栈顶，函数执行完毕其栈帧会自动从栈中弹出
- 消息队列
  - 消息队列负责存储将要执行的函数
  - 当我们触发一个事件时，其响应函数并不是直接就添加到调用栈中的，因为调用栈中有可能会存在一些还没有执行完的代码
  - 事件触发后，JS引擎是将事件响应函数插入到消息队列中排队，等至调用栈空，响应函数入栈
  - 定时器的本质，就是在指定时间后将函数添加到消息队列中

### 8.18.BOM概述

- BOM
  - 浏览器对象模型
  - BOM为我们提供了一组对象，通过这组对象可以完成对浏览器的各种操作
  - BOM对象
    - Window ： 代表浏览器窗口（全局对象）
    - Navigator ： 浏览器的对象（可以用来识别浏览器）
    - Location ： 浏览器的地址栏信息
    - History ： 浏览器的历史记录（控制浏览器前进后退）
    - Screen ： 屏幕的信息
  - BOM对象都是作为window对象的属性保存的，所以可以直接在JS中访问这些对象

### 8.19.Navigator

- navigator：浏览器的对象（可以用来识别浏览器）
  - userAgent：navigator.userAgent返回一个用来描述浏览器信息的字符串

### 8.20.Location

- location：浏览器地址栏的信息
  - location=新地址：跳转到一个新地址
  - location.assign()：跳转到一个新地址
  - location.replace()：跳转到一个新地址（无法通过回退按钮回退）
  - location.reload()：刷新页面，可以传递一个true来强制清缓存刷新
  - location.href：获取当前地址

### 8.21.History

- history：浏览器的历史记录（控制浏览器前进后退）
  - history.length：历史记录数量
  - history.back()：回退按钮
  - history.forward()：前进按钮
  - history.go()：可以向前跳转也可以向后跳转，参数使用正负值控制前后的步数

